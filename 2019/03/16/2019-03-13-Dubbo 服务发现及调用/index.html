<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Dubbo 服务引用"><meta name="keywords" content="DUBBO"><meta name="author" content="怀风,undefined"><meta name="copyright" content="怀风"><title>Dubbo 服务引用 | 我的梨子啊</title><link rel="shortcut icon" href="https://pic.52112.com/icon/256/20190107/27483/1369601.png"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Dubbo-服务引用"><span class="toc-number">1.</span> <span class="toc-text">Dubbo 服务引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#服务引用"><span class="toc-number">1.1.</span> <span class="toc-text">服务引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务引用的流程"><span class="toc-number">1.2.</span> <span class="toc-text">服务引用的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码解析"><span class="toc-number">1.3.</span> <span class="toc-text">源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化"><span class="toc-number">1.3.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务引用-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">服务引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RegistryProtocal中的refer"><span class="toc-number">1.3.3.</span> <span class="toc-text">RegistryProtocal中的refer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RegistryDirectory"><span class="toc-number">1.3.4.</span> <span class="toc-text">RegistryDirectory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DubboProtocal中的refer"><span class="toc-number">1.3.5.</span> <span class="toc-text">DubboProtocal中的refer</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/29188508?s=400&amp;u=f3fc60d5b158f5d5a25e5d7a5a26ce394a41435f&amp;v=4"></div><div class="author-info__name text-center">怀风</div><div class="author-info__description text-center">javaer</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">15</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container" style="background-image: url(true)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">我的梨子啊</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/archives/">首页</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">Dubbo 服务引用</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/DUBBO/">DUBBO</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Dubbo-服务引用"><a href="#Dubbo-服务引用" class="headerlink" title="Dubbo 服务引用"></a>Dubbo 服务引用</h1><h2 id="服务引用"><a href="#服务引用" class="headerlink" title="服务引用"></a>服务引用</h2><blockquote>
<ul>
<li>大家都知道Dubbo是由consumer,provider,registry这三大部分组成<br><img src="http://dubbo.apache.org/img/architecture.png" alt=""></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>那么consumer是如何发现provider并调用的呢,就是通过服务引用来实现的,也就是通过发现服务,然后进行调用</li>
</ul>
</blockquote>
<h2 id="服务引用的流程"><a href="#服务引用的流程" class="headerlink" title="服务引用的流程"></a>服务引用的流程</h2><blockquote>
<p><img src="/img/dubbo服务引用.jpg" alt=""></p>
</blockquote>
<blockquote>
<ul>
<li>dubbo服务引用的流程大概如上图,不难发现其流程跟dubbo服务暴露互逆,(关于Dubbo服务暴露<a href="http://blog.leishunyu.com/2019/01/25/2019-01-25-Dubbo%20%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2/">Dubbo服务暴露</a>)但最终也是通过invoker来完成我们服务引用</li>
<li>dubbo服务引用最终通过ProxyFactory将Invoker转化为调用的Service</li>
<li>dubbo服务引用过程与dubbo服务暴露相似,都是通过SPI,适配相应的协议,并将服务注册到注册中心,并最终完成服务引用</li>
</ul>
</blockquote>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略一部分代码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取服务接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">//此处省略 配置校验代码</span></span><br><span class="line">        Boolean b = isInit();</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span> &amp;&amp; getConsumer() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            b = getConsumer().isInit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; b) &#123;</span><br><span class="line">        	<span class="comment">//发现服务</span></span><br><span class="line">            getObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>首先我们来看一下ReferenceBean, ReferenceBean实现了InitializingBean, ApplicationContextAware, ApplicationListener这里同服务暴露一样,通过spring在初始化的时候进行服务引用</li>
</ul>
</blockquote>
<h3 id="服务引用-1"><a href="#服务引用-1" class="headerlink" title="服务引用"></a>服务引用</h3><blockquote>
<ul>
<li>我们看到这里都调用了getObject()方法,其实是调用了ReferenceConfig中的get()方法,接下来我们一起看下ReferenceConfig中的get()方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//配置校验</span></span><br><span class="line">       checkAndUpdateSubConfigs();</span><br><span class="line">	<span class="comment">//如果该服务已被销毁,则抛出异常</span></span><br><span class="line">       <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The invoker of ReferenceConfig("</span> + url + <span class="string">") has already destroyed!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果服务为空,则进行初始化,否则直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">           init();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ref;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里看到ReferenceConfig.get方法上加了一个锁,用来保证不会重复发现服务,而该方法的核心在于init()方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       initialized = <span class="keyword">true</span>;</span><br><span class="line">       checkStubAndLocal(interfaceClass);</span><br><span class="line">       <span class="comment">//校验mock</span></span><br><span class="line">       checkMock(interfaceClass);</span><br><span class="line">       Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">       </span><br><span class="line">	<span class="comment">//省略对参数解析设置 ...</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建代理对象</span></span><br><span class="line">       ref = createProxy(map);</span><br><span class="line"></span><br><span class="line">       ApplicationModel.initConsumerModel(getUniqueServiceName(), buildConsumerModel(attributes));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里通过对参数的解析来创建服务代理, createProxy()方法是整个服务引用初始化的关键</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> T <span class="title">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">     URL tmpUrl = <span class="keyword">new</span> URL(<span class="string">"temp"</span>, <span class="string">"localhost"</span>, <span class="number">0</span>, map);</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> isJvmRefer;</span><br><span class="line">     <span class="keyword">if</span> (isInjvm() == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果指定了url，则不要进行本地引用</span></span><br><span class="line">             isJvmRefer = <span class="keyword">false</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 默认情况下，引用本地服务（如果有）</span></span><br><span class="line">             isJvmRefer = InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         isJvmRefer = isInjvm();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (isJvmRefer) &#123;</span><br><span class="line">         URL url = <span class="keyword">new</span> URL(Constants.LOCAL_PROTOCOL, Constants.LOCALHOST_VALUE, <span class="number">0</span>, interfaceClass.getName()).addParameters(map);</span><br><span class="line">         invoker = refprotocol.refer(interfaceClass, url);</span><br><span class="line">         <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">             logger.info(<span class="string">"Using injvm service "</span> + interfaceClass.getName());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; <span class="comment">// 用户指定的URL，可以是对等地址，也可以是注册中心的地址.</span></span><br><span class="line">             String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">             <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">                     URL url = URL.valueOf(u);</span><br><span class="line">                     <span class="keyword">if</span> (StringUtils.isEmpty(url.getPath())) &#123;</span><br><span class="line">                         url = url.setPath(interfaceName);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                         urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// x来自注册中心配置的URL</span></span><br><span class="line">             checkRegistry();</span><br><span class="line">             List&lt;URL&gt; us = loadRegistries(<span class="keyword">false</span>);</span><br><span class="line">             <span class="keyword">if</span> (CollectionUtils.isNotEmpty(us)) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                     URL monitorUrl = loadMonitor(u);</span><br><span class="line">                     <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">                     &#125;</span><br><span class="line">                     urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (urls.isEmpty()) &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such any registry to reference "</span> + interfaceName + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" use dubbo version "</span> + Version.getVersion() + <span class="string">", please config &lt;dubbo:registry address=\"...\" /&gt; to your spring config."</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">//这里的refprotocol.refer即通过registryProtocol来进行发现</span></span><br><span class="line">         <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">             invoker = refprotocol.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">             URL registryURL = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                 invokers.add(refprotocol.refer(interfaceClass, url));</span><br><span class="line">                 <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                     registryURL = url; <span class="comment">// 使用最后一个注册表网址</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">// 注册表网址可用</span></span><br><span class="line">                 <span class="comment">// 仅在寄存器的群集可用时才使用RegistryAwareCluster</span></span><br><span class="line">                 URL u = registryURL.addParameter(Constants.CLUSTER_KEY, RegistryAwareCluster.NAME);</span><br><span class="line">                 <span class="comment">//调用者包装关系将是：RegistryAwareClusterInvoker（StaticDirectory） - &gt; FailoverClusterInvoker（RegistryDirectory，将执行路由） - &gt; Invoker                    invoker = cluster.join(new StaticDirectory(u, invokers));</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不是注册表网址，必须直接调用。</span></span><br><span class="line">             	<span class="comment">//这里要注意 cluster 最终都会被包装成 MockClusterWrapper(SPI的依赖注入) </span></span><br><span class="line">                 invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Boolean c = check;</span><br><span class="line">     <span class="keyword">if</span> (c == <span class="keyword">null</span> &amp;&amp; consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">         c = consumer.isCheck();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">         c = <span class="keyword">true</span>; <span class="comment">// default true</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (c &amp;&amp; !invoker.isAvailable()) &#123;</span><br><span class="line">         <span class="comment">// 如果提供者暂时不可用，则允许消费者稍后重试</span></span><br><span class="line">         initialized = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to check the status of the service "</span> + interfaceName + <span class="string">". No provider available for the service "</span> + (group == <span class="keyword">null</span> ? <span class="string">""</span> : group + <span class="string">"/"</span>) + interfaceName + (version == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">":"</span> + version) + <span class="string">" from the url "</span> + invoker.getUrl() + <span class="string">" to the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" use dubbo version "</span> + Version.getVersion());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">         logger.info(<span class="string">"Refer dubbo service "</span> + interfaceClass.getName() + <span class="string">" from url "</span> + invoker.getUrl());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@since</span> 2.7.0</span></span><br><span class="line"><span class="comment">      * ServiceData Store</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     MetadataReportService metadataReportService = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> ((metadataReportService = getMetadataReportService()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         URL consumerURL = <span class="keyword">new</span> URL(Constants.CONSUMER_PROTOCOL, map.remove(Constants.REGISTER_IP_KEY), <span class="number">0</span>, map.get(Constants.INTERFACE_KEY), map);</span><br><span class="line">         metadataReportService.publishConsumer(consumerURL);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// create service proxy</span></span><br><span class="line">     <span class="keyword">return</span> (T) proxyFactory.getProxy(invoker);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里可以看到dubbo在服务引用中也可以使用本地服务的发现,但是可看到这一块已经被标记为过时,我的理解是dubbo作为一个RPC框架,本地服务还通过dubbo去调用,肯定与dubbo本身的意义不相匹配,所以便不推荐使用</li>
<li>这块代码我们可以发现同服务暴露一样,会将consumer注册到所有配置的注册中心上去,而refprotocol.refer则是服务引用的核心代码</li>
<li>cluster对invoker进行了一层包装,以便应对后续服务调用中出现的异常情况进行处理</li>
<li>最后我们的invoker将通过代理工厂转换为可以调用的代理服务</li>
</ul>
</blockquote>
<h3 id="RegistryProtocal中的refer"><a href="#RegistryProtocal中的refer" class="headerlink" title="RegistryProtocal中的refer"></a>RegistryProtocal中的refer</h3><figure class="highlight java"><figcaption><span>RegistryProtocal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       url = url.setProtocol(url.getParameter(REGISTRY_KEY, DEFAULT_REGISTRY)).removeParameter(REGISTRY_KEY);</span><br><span class="line">       <span class="comment">//获取注册中心</span></span><br><span class="line">       Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">       <span class="comment">//如果是注册中心的服务,直接返回注册中心类型的invoker</span></span><br><span class="line">       <span class="keyword">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class="line">           <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// group="a,b" or group="*"</span></span><br><span class="line">       Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">       String group = qs.get(Constants.GROUP_KEY);</span><br><span class="line">       <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="number">1</span> || <span class="string">"*"</span>.equals(group)) &#123;</span><br><span class="line">               <span class="keyword">return</span> doRefer(getMergeableCluster(), registry, type, url);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//发现服务</span></span><br><span class="line">       <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">//创建并设置注册目录对象</span></span><br><span class="line">       RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">       directory.setRegistry(registry);</span><br><span class="line">       directory.setProtocol(protocol);</span><br><span class="line">       <span class="comment">// all attributes of REFER_KEY</span></span><br><span class="line">       Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">       URL subscribeUrl = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">       <span class="keyword">if</span> (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">           directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">           <span class="comment">//注册服务</span></span><br><span class="line">           registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">       &#125;</span><br><span class="line">       directory.buildRouterChain(subscribeUrl);</span><br><span class="line">       <span class="comment">//订阅服务</span></span><br><span class="line">       directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,</span><br><span class="line">               PROVIDERS_CATEGORY + <span class="string">","</span> + CONFIGURATORS_CATEGORY + <span class="string">","</span> + ROUTERS_CATEGORY));</span><br><span class="line">	<span class="comment">//装饰Invoker</span></span><br><span class="line">       Invoker invoker = cluster.join(directory);</span><br><span class="line">       ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br><span class="line">       <span class="keyword">return</span> invoker;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>在RegistryProtocal中,我们看到了cluster.join(directory),在ReferenceConfig中也出现过,在ReferenceConfig中没有注册中心的时候将直接使用装饰invoker,以供我们接下来服务调用来做集群容错</li>
<li>服务引用在RegistryProtocal中的核心方法即为doRefer方法</li>
</ul>
</blockquote>
<h3 id="RegistryDirectory"><a href="#RegistryDirectory" class="headerlink" title="RegistryDirectory"></a>RegistryDirectory</h3><figure class="highlight java"><figcaption><span>RegistryDirectory</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将网址转换为调用者，如果网址已被引用，则不会重新引用。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> urls</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> invokers</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class="line">       Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">       &#125;</span><br><span class="line">       Set&lt;String&gt; keys = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       String queryProtocols = <span class="keyword">this</span>.queryMap.get(Constants.PROTOCOL_KEY);</span><br><span class="line">       <span class="keyword">for</span> (URL providerUrl : urls) &#123;</span><br><span class="line">           <span class="comment">// 如果在参考侧配置协议，则仅选择匹配协议</span></span><br><span class="line">           <span class="keyword">if</span> (queryProtocols != <span class="keyword">null</span> &amp;&amp; queryProtocols.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">boolean</span> accept = <span class="keyword">false</span>;</span><br><span class="line">               String[] acceptProtocols = queryProtocols.split(<span class="string">","</span>);</span><br><span class="line">               <span class="keyword">for</span> (String acceptProtocol : acceptProtocols) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (providerUrl.getProtocol().equals(acceptProtocol)) &#123;</span><br><span class="line">                       accept = <span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (!accept) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) &#123;</span><br><span class="line">               logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported protocol "</span> + providerUrl.getProtocol() +</span><br><span class="line">                       <span class="string">" in notified url: "</span> + providerUrl + <span class="string">" from registry "</span> + getUrl().getAddress() +</span><br><span class="line">                       <span class="string">" to consumer "</span> + NetUtils.getLocalHost() + <span class="string">", supported protocol: "</span> +</span><br><span class="line">                       ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           URL url = mergeUrl(providerUrl);</span><br><span class="line"></span><br><span class="line">           String key = url.toFullString(); <span class="comment">// 参数URL已排序</span></span><br><span class="line">           <span class="keyword">if</span> (keys.contains(key)) &#123; <span class="comment">//重复的网址</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           keys.add(key);</span><br><span class="line">           <span class="comment">// 缓存键是不与消费者方参数合并的URL，无论消费者如何组合参数，如果服务器URL更改，则再次引用</span></span><br><span class="line">           Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// 本地发现</span></span><br><span class="line">           Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="keyword">null</span> ? <span class="keyword">null</span> : localUrlInvokerMap.get(key);</span><br><span class="line">           <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123; <span class="comment">// 不在缓存中，请再次发现</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">boolean</span> enabled = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="keyword">if</span> (url.hasParameter(Constants.DISABLED_KEY)) &#123;</span><br><span class="line">                       enabled = !url.getParameter(Constants.DISABLED_KEY, <span class="keyword">false</span>);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       enabled = url.getParameter(Constants.ENABLED_KEY, <span class="keyword">true</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                       invoker = <span class="keyword">new</span> InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                   logger.error(<span class="string">"Failed to refer invoker for interface:"</span> + serviceType + <span class="string">",url:("</span> + url + <span class="string">")"</span> + t.getMessage(), t);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123; <span class="comment">// Put new invoker in cache</span></span><br><span class="line">                   newUrlInvokerMap.put(key, invoker);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               newUrlInvokerMap.put(key, invoker);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       keys.clear();</span><br><span class="line">       <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>那我们的服务最后是如何通相应协议打开consumer和provider的链接呢,关键代码就在RegistryDirectory的toInvokers方法,将url转换成具体的invoker,这个方法在订阅服务的时候会被触发,并且这里做了一层缓存,防止服务被多次引用</li>
</ul>
</blockquote>
<h3 id="DubboProtocal中的refer"><a href="#DubboProtocal中的refer" class="headerlink" title="DubboProtocal中的refer"></a>DubboProtocal中的refer</h3><figure class="highlight java"><figcaption><span>DubboProtocol</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// create rpc invoker.</span></span><br><span class="line">       DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">       invokers.add(invoker);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> invoker;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里我们以Dubbo协议为例,看到DubboProtocal中的refer很简单,就是创建一个netty客户端,与provider进行连接返回一个Invoker即完成了一次服务的引用</li>
<li>最后通过ProxyFactory的字节码结束,生成代理的可供调用的服务,到这里dubbo服务引用的流程就结束了,可以看出服务引用与服务暴露的过程中有很多类似的地方,其中还有很多细节没有展开,这也将是后续学习的重点</li>
</ul>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">怀风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.leishunyu.com/2019/03/16/2019-03-13-Dubbo 服务发现及调用/">http://blog.leishunyu.com/2019/03/16/2019-03-13-Dubbo 服务发现及调用/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.leishunyu.com" target="_blank">我的梨子啊</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DUBBO/">DUBBO</a></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="next-post pull-right"><a href="/2019/01/25/2019-01-25-Dubbo 服务暴露/"><span>Dubbo 服务暴露</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By 怀风</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>