<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="javaer"><meta name="keywords" content=""><meta name="author" content="怀风,undefined"><meta name="copyright" content="怀风"><title>那些疯狂到以为自己能够改变世界的人才能真正改变世界 | 我的梨子啊</title><link rel="shortcut icon" href="https://pic.52112.com/icon/256/20190107/27483/1369601.png"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/29188508?s=400&amp;u=f3fc60d5b158f5d5a25e5d7a5a26ce394a41435f&amp;v=4"></div><div class="author-info__name text-center">怀风</div><div class="author-info__description text-center">javaer</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">16</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div></div></div><nav class="no-bg" id="nav" style="background-image: url(true)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">我的梨子啊</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/archives/">首页</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="site-info"><div id="site-title">我的梨子啊</div><div id="site-sub-title">那些疯狂到以为自己能够改变世界的人才能真正改变世界</div><div id="site-social-icons"> <a class="social-icon" href="https://github.com/Leishunyu/" target="_blank"><i class="fa fa-github"></i></a><a class="social-icon" href="https://weibo.com/u/2394913967" target="_blank"><i class="fa fa-weibo"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/27/2019-03-27-Netty -HashedWheelTimer时间轮学习/">Netty HashedWheelTimer时间轮源码学习</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Netty/">Netty</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Netty/">Netty</a></span><div class="content"><h1 id="HashedWheelTimer时间轮源码学习"><a href="#HashedWheelTimer时间轮源码学习" class="headerlink" title="HashedWheelTimer时间轮源码学习"></a>HashedWheelTimer时间轮源码学习</h1><h2 id="HashedWheelTimer时间轮的简介"><a href="#HashedWheelTimer时间轮的简介" class="headerlink" title="HashedWheelTimer时间轮的简介"></a>HashedWheelTimer时间轮的简介</h2><blockquote>
<ul>
<li>HashedWheelTimer是Netty中的一个基础工具类,主要用来高效处理大量定时任务,且任务对时间精度要求相对不高,  比如链接超时管理等场景, 缺点是, 内存占用相对较高。但是在使用时要注意任务里不要有太耗时的操作, 否则会阻塞Worker线程, 导致tick不准</li>
<li>HashedWheelTimer主要还是一个DelayQueue和一个时间轮算法组合</li>
<li>如下图,可以看到HashedWheelTimer是由一个环形链表及数组构成<br><img src="https://images2018.cnblogs.com/blog/600147/201712/600147-20171202215241038-1756544686.png" alt="HashedWheelTimer原理图"></li>
<li>如下图,可以解释为什么在使用HashedWheelTimer不能有太耗时的操作,因为worker的执行时,任务是串行的<br><img src="/img/时间轮1.jpg" alt="HashedWheelTimer执行过程"></li>
<li>如下图,可以看到HashedWheelTimer是由HashedWheelBucket数组, HashedWheelTimeout链表和工作线程Worker组成,所以我们的源码分析也主要从这几个类入手<br><img src="/img/时间轮2.jpg" alt="HashedWheelTimer类图"></li>
</ul>
</blockquote>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="HashedWheelTimer中的基本字段"><a href="#HashedWheelTimer中的基本字段" class="headerlink" title="HashedWheelTimer中的基本字段"></a>HashedWheelTimer中的基本字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例计数器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger INSTANCE_COUNTER = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">   <span class="comment">//实例过多警告值</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicBoolean WARNED_TOO_MANY_INSTANCES = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">   <span class="comment">//实际数量限制</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTANCE_COUNT_LIMIT = <span class="number">64</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MILLISECOND_NANOS = TimeUnit.MILLISECONDS.toNanos(<span class="number">1</span>);</span><br><span class="line">   <span class="comment">//资源泄漏检测器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ResourceLeakDetector&lt;HashedWheelTimer&gt; leakDetector = ResourceLeakDetectorFactory.instance()</span><br><span class="line">           .newResourceLeakDetector(HashedWheelTimer.class, <span class="number">1</span>);</span><br><span class="line">   <span class="comment">//工作线程状态更新</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimer&gt; WORKER_STATE_UPDATER =</span><br><span class="line">           AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimer.class, <span class="string">"workerState"</span>);</span><br><span class="line">   <span class="comment">//泄漏值</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ResourceLeakTracker&lt;HashedWheelTimer&gt; leak;</span><br><span class="line">   <span class="comment">//工作对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">   <span class="comment">//工作线程</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Thread workerThread;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_INIT = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_STARTED = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_SHUTDOWN = <span class="number">2</span>;</span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"unused"</span>, <span class="string">"FieldMayBeFinal"</span> &#125;)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> workerState; <span class="comment">// 0 - init, 1 - started, 2 - shut down</span></span><br><span class="line">   <span class="comment">//tick的时长，也就是指针多久转一格</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> tickDuration;</span><br><span class="line">   <span class="comment">//时间轮数组</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelBucket[] wheel;</span><br><span class="line">   <span class="comment">// 这是一个标示符，用来快速计算任务应该呆的格子。</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mask;</span><br><span class="line">   <span class="comment">//开始时间已初始化</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startTimeInitialized = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">   <span class="comment">//任务队列</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;HashedWheelTimeout&gt; timeouts = PlatformDependent.newMpscQueue();</span><br><span class="line">   <span class="comment">//关闭的任务队列</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;HashedWheelTimeout&gt; cancelledTimeouts = PlatformDependent.newMpscQueue();</span><br><span class="line">   <span class="comment">//挂起超时次数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong pendingTimeouts = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">   <span class="comment">//最大挂起超时次数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxPendingTimeouts;</span><br><span class="line">   <span class="comment">//开始时间</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> startTime;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>从以上源码中我们可以大概了解到一个时间轮的执行依赖哪些条件,其中我们的任务都是基于Queue来实现的,但是这里我们要注意的是,这里的Queue是基于jctools中的Queue,以此得到更高的性能</li>
<li>mask标识符用来做位运算</li>
<li>通过原子类来保证并发情况下的一致性</li>
<li>这里我觉得值得我们学习的地方,是此处引用了资源泄露检测器,当资源超过64的时候就会进行告警,在细节方面netty考虑的非常全面,这个也是我们在平时编码的时需要学习的</li>
</ul>
</blockquote>
<h3 id="HashedWheelTimer构造方法"><a href="#HashedWheelTimer构造方法" class="headerlink" title="HashedWheelTimer构造方法"></a>HashedWheelTimer构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           ThreadFactory threadFactory, // 用来创建worker线程</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">long</span> tickDuration,// tick的时长，也就是指针多久转一格</span></span></span><br><span class="line"><span class="function"><span class="params">           TimeUnit unit, // tickDuration的时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> ticksPerWheel, // 一圈有几格</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">boolean</span> leakDetection, // 是否开启内存泄露检测</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">long</span> maxPendingTimeouts  //最大挂起超时次数</span></span></span><br><span class="line"><span class="function"><span class="params">   )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (threadFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"threadFactory"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (unit == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"unit"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (tickDuration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"tickDuration must be greater than 0: "</span> + tickDuration);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"ticksPerWheel must be greater than 0: "</span> + ticksPerWheel);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将ticksPerWheel标准化为2的幂并初始化轮子.</span></span><br><span class="line">       wheel = createWheel(ticksPerWheel);</span><br><span class="line">       <span class="comment">// 这是一个标示符，用来快速计算任务应该呆的格子。</span></span><br><span class="line">       <span class="comment">// 我们知道，给定一个deadline的定时任务，其应该呆的格子=deadline%wheel.length.但是%操作是个相对耗时的操作，所以使用一种变通的位运算代替：</span></span><br><span class="line">       <span class="comment">// 因为一圈的长度为2的n次方，mask = 2^n-1后低位将全部是1，然后deadline&amp;mast == deadline%wheel.length</span></span><br><span class="line">       <span class="comment">// java中的HashMap也是使用这种处理方法</span></span><br><span class="line">       mask = wheel.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 转换成纳秒处理</span></span><br><span class="line">       <span class="keyword">long</span> duration = unit.toNanos(tickDuration);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 校验是否存在溢出。即指针转动的时间间隔不能太长而导致tickDuration*wheel.length&gt;Long.MAX_VALUE</span></span><br><span class="line">       <span class="keyword">if</span> (duration &gt;= Long.MAX_VALUE / wheel.length) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                   <span class="string">"tickDuration: %d (expected: 0 &lt; tickDuration in nanos &lt; %d"</span>,</span><br><span class="line">                   tickDuration, Long.MAX_VALUE / wheel.length));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (duration &lt; MILLISECOND_NANOS) &#123;</span><br><span class="line">           <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">               logger.warn(<span class="string">"Configured tickDuration %d smaller then %d, using 1ms."</span>,</span><br><span class="line">                           tickDuration, MILLISECOND_NANOS);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">this</span>.tickDuration = MILLISECOND_NANOS;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.tickDuration = duration;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建worker线程</span></span><br><span class="line">       workerThread = threadFactory.newThread(worker);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 这里默认是启动内存泄露检测：当HashedWheelTimer实例超过当前cpu可用核数*4的时候，将发出警告</span></span><br><span class="line">       leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.maxPendingTimeouts = maxPendingTimeouts;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (INSTANCE_COUNTER.incrementAndGet() &gt; INSTANCE_COUNT_LIMIT &amp;&amp;</span><br><span class="line">           WARNED_TOO_MANY_INSTANCES.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">           <span class="comment">//发起警告</span></span><br><span class="line">           reportTooManyInstances();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里要注意,如果ticksPerWheel的默认值是512</li>
<li>HashedWheelTimer其实最终都是转换成纳秒处理的</li>
</ul>
</blockquote>
<h3 id="HashedWheelTimer的createWheel方法"><a href="#HashedWheelTimer的createWheel方法" class="headerlink" title="HashedWheelTimer的createWheel方法"></a>HashedWheelTimer的createWheel方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HashedWheelBucket[] createWheel(<span class="keyword">int</span> ticksPerWheel) &#123;</span><br><span class="line">       <span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                   <span class="string">"ticksPerWheel must be greater than 0: "</span> + ticksPerWheel);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (ticksPerWheel &gt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                   <span class="string">"ticksPerWheel may not be greater than 2^30: "</span> + ticksPerWheel);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 初始化ticksPerWheel的值为不小于ticksPerWheel的最小2的n次方</span></span><br><span class="line">       ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);</span><br><span class="line">       <span class="comment">// 初始化wheel数组</span></span><br><span class="line">       HashedWheelBucket[] wheel = <span class="keyword">new</span> HashedWheelBucket[ticksPerWheel];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wheel.length; i ++) &#123;</span><br><span class="line">           wheel[i] = <span class="keyword">new</span> HashedWheelBucket();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> wheel;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里要注意,创建时间轮数组的时候,最大长度不能超过2的30次方</li>
</ul>
</blockquote>
<h3 id="HashedWheelTimer的normalizeTicksPerWheel方法"><a href="#HashedWheelTimer的normalizeTicksPerWheel方法" class="headerlink" title="HashedWheelTimer的normalizeTicksPerWheel方法"></a>HashedWheelTimer的normalizeTicksPerWheel方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化ticksPerWheel的值为不小于ticksPerWheel的最小2的n次方</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">normalizeTicksPerWheel</span><span class="params">(<span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> normalizedTicksPerWheel = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (normalizedTicksPerWheel &lt; ticksPerWheel) &#123;</span><br><span class="line">           normalizedTicksPerWheel &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> normalizedTicksPerWheel;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里通过位运算来初始化每个轮盘的刻度</li>
<li>但这里有个问题,如果轮盘大小指定过大,这里的循环次数也会更多,性能会存在问题,此处可以进行优化[jdk1.8 hashmap的hash算法,后面深入了解下]</li>
</ul>
</blockquote>
<h3 id="HashedWheelTimer的start方法-时间轮启动的方法"><a href="#HashedWheelTimer的start方法-时间轮启动的方法" class="headerlink" title="HashedWheelTimer的start方法(时间轮启动的方法)"></a>HashedWheelTimer的start方法(时间轮启动的方法)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动时间轮。这个方法其实不需要显示的主动调用，因为在添加定时任务（newTimeout()方法）的时候会自动调用此方法。</span></span><br><span class="line">   <span class="comment">// 这个是合理的设计，因为如果时间轮里根本没有定时任务，启动时间轮也是空耗资源</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 判断当前时间轮的状态，如果是初始化，则启动worker线程，启动整个时间轮；如果已经启动则略过；如果是已经停止，则报错</span></span><br><span class="line">       <span class="comment">// 这里是一个Lock Free的设计。因为可能有多个线程调用启动方法，这里使用AtomicIntegerFieldUpdater原子的更新时间轮的状态</span></span><br><span class="line">       <span class="keyword">switch</span> (WORKER_STATE_UPDATER.get(<span class="keyword">this</span>)) &#123;</span><br><span class="line">       	 <span class="comment">//如果时间轮还没有启动,则更改状态并启动</span></span><br><span class="line">           <span class="keyword">case</span> WORKER_STATE_INIT:</span><br><span class="line">               <span class="keyword">if</span> (WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_INIT, WORKER_STATE_STARTED)) &#123;</span><br><span class="line">                   workerThread.start();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">//如果当前时间轮已经启动,则跳出该逻辑</span></span><br><span class="line">           <span class="keyword">case</span> WORKER_STATE_STARTED:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">//如果是关闭状态,抛出无法启动异常</span></span><br><span class="line">           <span class="keyword">case</span> WORKER_STATE_SHUTDOWN:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"cannot be started once stopped"</span>);</span><br><span class="line">           <span class="comment">//如果工作状态未指定,则表示该程序异常,直接error</span></span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Invalid WorkerState"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 等待worker线程初始化时间轮的启动时间</span></span><br><span class="line">       <span class="keyword">while</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               startTimeInitialized.await();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">               <span class="comment">// Ignore - it will be ready very soon.</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/16/2019-03-16-Dubbo 服务引用/">Dubbo 服务引用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DUBBO/">DUBBO</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/DUBBO/">DUBBO</a></span><div class="content"><h1 id="Dubbo-服务引用"><a href="#Dubbo-服务引用" class="headerlink" title="Dubbo 服务引用"></a>Dubbo 服务引用</h1><h2 id="服务引用"><a href="#服务引用" class="headerlink" title="服务引用"></a>服务引用</h2><blockquote>
<ul>
<li>大家都知道Dubbo是由consumer,provider,registry这三大部分组成<br><img src="http://dubbo.apache.org/img/architecture.png" alt=""></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>那么consumer是如何发现provider并调用的呢,就是通过服务引用来实现的,也就是通过发现服务,然后进行调用</li>
</ul>
</blockquote>
<h2 id="服务引用的流程"><a href="#服务引用的流程" class="headerlink" title="服务引用的流程"></a>服务引用的流程</h2><blockquote>
<p><img src="/img/dubbo服务引用.jpg" alt=""></p>
</blockquote>
<blockquote>
<ul>
<li>dubbo服务引用的流程大概如上图,不难发现其流程跟dubbo服务暴露互逆,(关于Dubbo服务暴露<a href="http://blog.leishunyu.com/2019/01/25/2019-01-25-Dubbo%20%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2/">Dubbo服务暴露</a>)但最终也是通过invoker来完成我们服务引用</li>
<li>dubbo服务引用最终通过ProxyFactory将Invoker转化为调用的Service</li>
<li>dubbo服务引用过程与dubbo服务暴露相似,都是通过SPI,适配相应的协议,并将服务注册到注册中心,并最终完成服务引用</li>
</ul>
</blockquote>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略一部分代码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取服务接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">//此处省略 配置校验代码</span></span><br><span class="line">        Boolean b = isInit();</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span> &amp;&amp; getConsumer() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            b = getConsumer().isInit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; b) &#123;</span><br><span class="line">        	<span class="comment">//发现服务</span></span><br><span class="line">            getObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>首先我们来看一下ReferenceBean, ReferenceBean实现了InitializingBean, ApplicationContextAware, ApplicationListener这里同服务暴露一样,通过spring在初始化的时候进行服务引用</li>
</ul>
</blockquote>
<h3 id="服务引用-1"><a href="#服务引用-1" class="headerlink" title="服务引用"></a>服务引用</h3><blockquote>
<ul>
<li>我们看到这里都调用了getObject()方法,其实是调用了ReferenceConfig中的get()方法,接下来我们一起看下ReferenceConfig中的get()方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//配置校验</span></span><br><span class="line">       checkAndUpdateSubConfigs();</span><br><span class="line">	<span class="comment">//如果该服务已被销毁,则抛出异常</span></span><br><span class="line">       <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The invoker of ReferenceConfig("</span> + url + <span class="string">") has already destroyed!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果服务为空,则进行初始化,否则直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">           init();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ref;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里看到ReferenceConfig.get方法上加了一个锁,用来保证不会重复发现服务,而该方法的核心在于init()方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       initialized = <span class="keyword">true</span>;</span><br><span class="line">       checkStubAndLocal(interfaceClass);</span><br><span class="line">       <span class="comment">//校验mock</span></span><br><span class="line">       checkMock(interfaceClass);</span><br><span class="line">       Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">       </span><br><span class="line">	<span class="comment">//省略对参数解析设置 ...</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建代理对象</span></span><br><span class="line">       ref = createProxy(map);</span><br><span class="line"></span><br><span class="line">       ApplicationModel.initConsumerModel(getUniqueServiceName(), buildConsumerModel(attributes));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里通过对参数的解析来创建服务代理, createProxy()方法是整个服务引用初始化的关键</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> T <span class="title">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">     URL tmpUrl = <span class="keyword">new</span> URL(<span class="string">"temp"</span>, <span class="string">"localhost"</span>, <span class="number">0</span>, map);</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> isJvmRefer;</span><br><span class="line">     <span class="keyword">if</span> (isInjvm() == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果指定了url，则不要进行本地引用</span></span><br><span class="line">             isJvmRefer = <span class="keyword">false</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 默认情况下，引用本地服务（如果有）</span></span><br><span class="line">             isJvmRefer = InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         isJvmRefer = isInjvm();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (isJvmRefer) &#123;</span><br><span class="line">         URL url = <span class="keyword">new</span> URL(Constants.LOCAL_PROTOCOL, Constants.LOCALHOST_VALUE, <span class="number">0</span>, interfaceClass.getName()).addParameters(map);</span><br><span class="line">         invoker = refprotocol.refer(interfaceClass, url);</span><br><span class="line">         <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">             logger.info(<span class="string">"Using injvm service "</span> + interfaceClass.getName());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; <span class="comment">// 用户指定的URL，可以是对等地址，也可以是注册中心的地址.</span></span><br><span class="line">             String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">             <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">                     URL url = URL.valueOf(u);</span><br><span class="line">                     <span class="keyword">if</span> (StringUtils.isEmpty(url.getPath())) &#123;</span><br><span class="line">                         url = url.setPath(interfaceName);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                         urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// x来自注册中心配置的URL</span></span><br><span class="line">             checkRegistry();</span><br><span class="line">             List&lt;URL&gt; us = loadRegistries(<span class="keyword">false</span>);</span><br><span class="line">             <span class="keyword">if</span> (CollectionUtils.isNotEmpty(us)) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                     URL monitorUrl = loadMonitor(u);</span><br><span class="line">                     <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">                     &#125;</span><br><span class="line">                     urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (urls.isEmpty()) &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such any registry to reference "</span> + interfaceName + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" use dubbo version "</span> + Version.getVersion() + <span class="string">", please config &lt;dubbo:registry address=\"...\" /&gt; to your spring config."</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">//这里的refprotocol.refer即通过registryProtocol来进行发现</span></span><br><span class="line">         <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">             invoker = refprotocol.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">             URL registryURL = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                 invokers.add(refprotocol.refer(interfaceClass, url));</span><br><span class="line">                 <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                     registryURL = url; <span class="comment">// 使用最后一个注册表网址</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">// 注册表网址可用</span></span><br><span class="line">                 <span class="comment">// 仅在寄存器的群集可用时才使用RegistryAwareCluster</span></span><br><span class="line">                 URL u = registryURL.addParameter(Constants.CLUSTER_KEY, RegistryAwareCluster.NAME);</span><br><span class="line">                 <span class="comment">//调用者包装关系将是：RegistryAwareClusterInvoker（StaticDirectory） - &gt; FailoverClusterInvoker（RegistryDirectory，将执行路由） - &gt; Invoker                    invoker = cluster.join(new StaticDirectory(u, invokers));</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不是注册表网址，必须直接调用。</span></span><br><span class="line">             	<span class="comment">//这里要注意 cluster 最终都会被包装成 MockClusterWrapper(SPI的依赖注入) </span></span><br><span class="line">                 invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Boolean c = check;</span><br><span class="line">     <span class="keyword">if</span> (c == <span class="keyword">null</span> &amp;&amp; consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">         c = consumer.isCheck();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">         c = <span class="keyword">true</span>; <span class="comment">// default true</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (c &amp;&amp; !invoker.isAvailable()) &#123;</span><br><span class="line">         <span class="comment">// 如果提供者暂时不可用，则允许消费者稍后重试</span></span><br><span class="line">         initialized = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to check the status of the service "</span> + interfaceName + <span class="string">". No provider available for the service "</span> + (group == <span class="keyword">null</span> ? <span class="string">""</span> : group + <span class="string">"/"</span>) + interfaceName + (version == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">":"</span> + version) + <span class="string">" from the url "</span> + invoker.getUrl() + <span class="string">" to the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" use dubbo version "</span> + Version.getVersion());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">         logger.info(<span class="string">"Refer dubbo service "</span> + interfaceClass.getName() + <span class="string">" from url "</span> + invoker.getUrl());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@since</span> 2.7.0</span></span><br><span class="line"><span class="comment">      * ServiceData Store</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     MetadataReportService metadataReportService = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> ((metadataReportService = getMetadataReportService()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         URL consumerURL = <span class="keyword">new</span> URL(Constants.CONSUMER_PROTOCOL, map.remove(Constants.REGISTER_IP_KEY), <span class="number">0</span>, map.get(Constants.INTERFACE_KEY), map);</span><br><span class="line">         metadataReportService.publishConsumer(consumerURL);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// create service proxy</span></span><br><span class="line">     <span class="keyword">return</span> (T) proxyFactory.getProxy(invoker);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里可以看到dubbo在服务引用中也可以使用本地服务的发现,但是可看到这一块已经被标记为过时,我的理解是dubbo作为一个RPC框架,本地服务还通过dubbo去调用,肯定与dubbo本身的意义不相匹配,所以便不推荐使用</li>
<li>这块代码我们可以发现同服务暴露一样,会将consumer注册到所有配置的注册中心上去,而refprotocol.refer则是服务引用的核心代码</li>
<li>cluster对invoker进行了一层包装,以便应对后续服务调用中出现的异常情况进行处理</li>
<li>最后我们的invoker将通过代理工厂转换为可以调用的代理服务</li>
</ul>
</blockquote>
<h3 id="RegistryProtocal中的refer"><a href="#RegistryProtocal中的refer" class="headerlink" title="RegistryProtocal中的refer"></a>RegistryProtocal中的refer</h3><figure class="highlight java"><figcaption><span>RegistryProtocal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       url = url.setProtocol(url.getParameter(REGISTRY_KEY, DEFAULT_REGISTRY)).removeParameter(REGISTRY_KEY);</span><br><span class="line">       <span class="comment">//获取注册中心</span></span><br><span class="line">       Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">       <span class="comment">//如果是注册中心的服务,直接返回注册中心类型的invoker</span></span><br><span class="line">       <span class="keyword">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class="line">           <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// group="a,b" or group="*"</span></span><br><span class="line">       Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">       String group = qs.get(Constants.GROUP_KEY);</span><br><span class="line">       <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="number">1</span> || <span class="string">"*"</span>.equals(group)) &#123;</span><br><span class="line">               <span class="keyword">return</span> doRefer(getMergeableCluster(), registry, type, url);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//发现服务</span></span><br><span class="line">       <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">//创建并设置注册目录对象</span></span><br><span class="line">       RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">       directory.setRegistry(registry);</span><br><span class="line">       directory.setProtocol(protocol);</span><br><span class="line">       <span class="comment">// all attributes of REFER_KEY</span></span><br><span class="line">       Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">       URL subscribeUrl = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">       <span class="keyword">if</span> (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">           directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">           <span class="comment">//注册服务</span></span><br><span class="line">           registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">       &#125;</span><br><span class="line">       directory.buildRouterChain(subscribeUrl);</span><br><span class="line">       <span class="comment">//订阅服务</span></span><br><span class="line">       directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,</span><br><span class="line">               PROVIDERS_CATEGORY + <span class="string">","</span> + CONFIGURATORS_CATEGORY + <span class="string">","</span> + ROUTERS_CATEGORY));</span><br><span class="line">	<span class="comment">//装饰Invoker</span></span><br><span class="line">       Invoker invoker = cluster.join(directory);</span><br><span class="line">       ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br><span class="line">       <span class="keyword">return</span> invoker;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>在RegistryProtocal中,我们看到了cluster.join(directory),在ReferenceConfig中也出现过,在ReferenceConfig中没有注册中心的时候将直接使用装饰invoker,以供我们接下来服务调用来做集群容错</li>
<li>服务引用在RegistryProtocal中的核心方法即为doRefer方法</li>
</ul>
</blockquote>
<h3 id="RegistryDirectory"><a href="#RegistryDirectory" class="headerlink" title="RegistryDirectory"></a>RegistryDirectory</h3><figure class="highlight java"><figcaption><span>RegistryDirectory</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将网址转换为调用者，如果网址已被引用，则不会重新引用。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> urls</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> invokers</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class="line">       Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">       &#125;</span><br><span class="line">       Set&lt;String&gt; keys = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       String queryProtocols = <span class="keyword">this</span>.queryMap.get(Constants.PROTOCOL_KEY);</span><br><span class="line">       <span class="keyword">for</span> (URL providerUrl : urls) &#123;</span><br><span class="line">           <span class="comment">// 如果在参考侧配置协议，则仅选择匹配协议</span></span><br><span class="line">           <span class="keyword">if</span> (queryProtocols != <span class="keyword">null</span> &amp;&amp; queryProtocols.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">boolean</span> accept = <span class="keyword">false</span>;</span><br><span class="line">               String[] acceptProtocols = queryProtocols.split(<span class="string">","</span>);</span><br><span class="line">               <span class="keyword">for</span> (String acceptProtocol : acceptProtocols) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (providerUrl.getProtocol().equals(acceptProtocol)) &#123;</span><br><span class="line">                       accept = <span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (!accept) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) &#123;</span><br><span class="line">               logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported protocol "</span> + providerUrl.getProtocol() +</span><br><span class="line">                       <span class="string">" in notified url: "</span> + providerUrl + <span class="string">" from registry "</span> + getUrl().getAddress() +</span><br><span class="line">                       <span class="string">" to consumer "</span> + NetUtils.getLocalHost() + <span class="string">", supported protocol: "</span> +</span><br><span class="line">                       ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           URL url = mergeUrl(providerUrl);</span><br><span class="line"></span><br><span class="line">           String key = url.toFullString(); <span class="comment">// 参数URL已排序</span></span><br><span class="line">           <span class="keyword">if</span> (keys.contains(key)) &#123; <span class="comment">//重复的网址</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           keys.add(key);</span><br><span class="line">           <span class="comment">// 缓存键是不与消费者方参数合并的URL，无论消费者如何组合参数，如果服务器URL更改，则再次引用</span></span><br><span class="line">           Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// 本地发现</span></span><br><span class="line">           Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="keyword">null</span> ? <span class="keyword">null</span> : localUrlInvokerMap.get(key);</span><br><span class="line">           <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123; <span class="comment">// 不在缓存中，请再次发现</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">boolean</span> enabled = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="keyword">if</span> (url.hasParameter(Constants.DISABLED_KEY)) &#123;</span><br><span class="line">                       enabled = !url.getParameter(Constants.DISABLED_KEY, <span class="keyword">false</span>);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       enabled = url.getParameter(Constants.ENABLED_KEY, <span class="keyword">true</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                       invoker = <span class="keyword">new</span> InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                   logger.error(<span class="string">"Failed to refer invoker for interface:"</span> + serviceType + <span class="string">",url:("</span> + url + <span class="string">")"</span> + t.getMessage(), t);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123; <span class="comment">// Put new invoker in cache</span></span><br><span class="line">                   newUrlInvokerMap.put(key, invoker);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               newUrlInvokerMap.put(key, invoker);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       keys.clear();</span><br><span class="line">       <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>那我们的服务最后是如何通相应协议打开consumer和provider的链接呢,关键代码就在RegistryDirectory的toInvokers方法,将url转换成具体的invoker,这个方法在订阅服务的时候会被触发,并且这里做了一层缓存,防止服务被多次引用</li>
</ul>
</blockquote>
<h3 id="DubboProtocal中的refer"><a href="#DubboProtocal中的refer" class="headerlink" title="DubboProtocal中的refer"></a>DubboProtocal中的refer</h3><figure class="highlight java"><figcaption><span>DubboProtocol</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// create rpc invoker.</span></span><br><span class="line">       DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">       invokers.add(invoker);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> invoker;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里我们以Dubbo协议为例,看到DubboProtocal中的refer很简单,就是创建一个netty客户端,与provider进行连接返回一个Invoker即完成了一次服务的引用</li>
<li>最后通过ProxyFactory的字节码结束,生成代理的可供调用的服务,到这里dubbo服务引用的流程就结束了,可以看出服务引用与服务暴露的过程中有很多类似的地方,其中还有很多细节没有展开,这也将是后续学习的重点</li>
</ul>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/25/2019-01-25-Dubbo 服务暴露/">Dubbo 服务暴露</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DUBBO/">DUBBO</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/DUBBO/">DUBBO</a></span><div class="content"><h1 id="Dubbo-服务暴露"><a href="#Dubbo-服务暴露" class="headerlink" title="Dubbo 服务暴露"></a>Dubbo 服务暴露</h1><h2 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h2><blockquote>
<ul>
<li>大家都知道Dubbo是由consumer,provider,registry这三大部分组成<br><img src="http://dubbo.apache.org/img/architecture.png" alt=""></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>那么provider的如何将服务提供给consumer调用呢,就是通过服务暴露来实现的,也就是把我们原来单机架构中的接口,对外部暴露</li>
</ul>
</blockquote>
<h2 id="服务暴露的流程"><a href="#服务暴露的流程" class="headerlink" title="服务暴露的流程"></a>服务暴露的流程</h2><blockquote>
<p><img src="/img/dubbo服务暴露.png" alt=""></p>
</blockquote>
<blockquote>
<ul>
<li>dubbo服务暴露的流程大概如上图,在dubbo中,所有的服务都会被包装成一个invoker,这一点也将贯穿今后整个学习</li>
<li>dubbo服务暴露可以理解为两部分:本地暴露,远程暴露</li>
<li>本地暴露的接口通常用于我们直接invoke dubbo的接口,以及有些时候我们的服务既是provider又是consumer,避免远程调用造成的资源浪费</li>
<li>远程暴露则是将服务信息注册到registry,并且将服务通过网络提供给其他应用调用</li>
</ul>
</blockquote>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">213195494150089726L</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *此处省略其他代码</span></span><br><span class="line"><span class="comment">	 **/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"The service ready on spring started. service: "</span> + getInterface());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//服务暴露</span></span><br><span class="line">            export();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"deprecation"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	 <span class="comment">//此处省略....</span></span><br><span class="line">        <span class="keyword">if</span> (!supportedApplicationListener) &#123;</span><br><span class="line">            <span class="comment">//服务暴露</span></span><br><span class="line">            export();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>首先我们来看一下ServiceBean,ServiceBean实现了InitializingBean, ApplicationContextAware, ApplicationListener有没有觉得很熟悉,实现这几个类就能在spring初始化的时候do something</li>
</ul>
</blockquote>
<h3 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h3><blockquote>
<ul>
<li>我们看到这里都调用了export()方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (export == <span class="keyword">null</span>) &#123;</span><br><span class="line">               export = provider.getExport();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (delay == <span class="keyword">null</span>) &#123;</span><br><span class="line">               delay = provider.getDelay();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (export != <span class="keyword">null</span> &amp;&amp; !export) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (delay != <span class="keyword">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           delayExportExecutor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   doExport();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           doExport();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里看到ServiceConfig.export方法上加了一个锁,用来保证不会重复暴露服务,抛开上面的逻辑判断,在第一次初始化的时候,是直接走到了doExport()方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//省略判断代码</span></span><br><span class="line">	doExportUrls();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//加载注册中心的配置</span></span><br><span class="line">       List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">//把使用的协议注册到注册中心 </span></span><br><span class="line">       <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">           doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里dubbo支持多协议,可以看到通过for循环可以把配置的多种协议都导出,进行暴露</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">	 <span class="comment">//省略判断代码</span></span><br><span class="line">    <span class="comment">// 导出服务</span></span><br><span class="line">    String contextPath = protocolConfig.getContextpath();</span><br><span class="line">    <span class="keyword">if</span> ((contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span>) &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        contextPath = provider.getContextpath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String host = <span class="keyword">this</span>.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">    Integer port = <span class="keyword">this</span>.findConfigedPorts(protocolConfig, name, map);</span><br><span class="line">    URL url = <span class="keyword">new</span> URL(name, host, port, (contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span> ? <span class="string">""</span> : contextPath + <span class="string">"/"</span>) + path, map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">            .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String scope = url.getParameter(Constants.SCOPE_KEY);</span><br><span class="line">    <span class="comment">// 没有配置时不导出</span></span><br><span class="line">    <span class="keyword">if</span> (!Constants.SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">        <span class="comment">// 导出本地服务</span></span><br><span class="line">        <span class="keyword">if</span> (!Constants.SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            exportLocal(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 导出远程服务</span></span><br><span class="line">        <span class="keyword">if</span> (!Constants.SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to url "</span> + url);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (registryURLs != <span class="keyword">null</span> &amp;&amp; !registryURLs.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//将服务都注册到当前已有的注册中心上去</span></span><br><span class="line">                <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                    url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));</span><br><span class="line">                    <span class="comment">//判断是否有监控中心</span></span><br><span class="line">                    URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line">                    <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Register dubbo service "</span> + interfaceClass.getName() + <span class="string">" url "</span> + url + <span class="string">" to registry "</span> + registryURL);</span><br><span class="line">                    &#125;</span><br><span class="line">			<span class="comment">//对于providers，这用于启用自定义代理以生成invoker</span></span><br><span class="line">                    String proxy = url.getParameter(Constants.PROXY_KEY);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                        registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line">                    <span class="comment">//包装调用者和所有元数据的Invoker包装器</span></span><br><span class="line">                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">//没有注册中心直接暴露</span></span><br><span class="line">                Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                <span class="comment">//包装调用者和所有元数据的Invoker包装器</span></span><br><span class="line">                DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line">                Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                exporters.add(exporter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.urls.add(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露本地服务</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportLocal</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">        <span class="comment">//手动暴露一个本地服务</span></span><br><span class="line">        URL local = URL.valueOf(url.toFullString())</span><br><span class="line">                .setProtocol(Constants.LOCAL_PROTOCOL)</span><br><span class="line">                .setHost(LOCALHOST)</span><br><span class="line">                .setPort(<span class="number">0</span>);</span><br><span class="line">        Exporter&lt;?&gt; exporter = protocol.export(</span><br><span class="line">                proxyFactory.getInvoker(ref, (Class) interfaceClass, local));</span><br><span class="line">        exporters.add(exporter);</span><br><span class="line">        logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to local registry"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这你scope配置默认值是null,则本地服务和远程服务都导出,另外如果没有配置注册中心,将直接将接口暴露出去,我们可以根据自己所在的场景,选择都暴露还是指定暴露</li>
<li>由于dubbo也是支持多注册中心的,所以可以通过for循环,将多个服务都注册到当前已有的注册中心上去</li>
<li>在exportLocal方法这是将配置中解析好的url参数手动修改成本地协议进行服务暴露</li>
<li>ProxyFactory是通过SPI获取JavassistProxyFactory靠Javassist字节码技术动态的生成Invoker类,大家有兴趣的可以下去了解一下</li>
</ul>
</blockquote>
<h3 id="暴露的细节"><a href="#暴露的细节" class="headerlink" title="暴露的细节"></a>暴露的细节</h3><figure class="highlight java"><figcaption><span>ProtocolFilterWrapper</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolFilterWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line">    <span class="comment">//装饰者模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolFilterWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>在ServiceConfig中,通过SPI获取相应的Protocol,SPI中会对实现类进行装饰,每次执行protocol.exprot()方法的时候,其实都是执行的ProtocolFilterWrapper的protocol.exprot方法</li>
</ul>
</blockquote>
<figure class="highlight java"><figcaption><span>ProtocolFilterWrapper</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//如果是注册中心协议直接导出</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是则执行整个filter的责任链</span></span><br><span class="line">    <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//责任链模式,对filter进行逐个执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class="line">    Invoker&lt;T&gt; last = invoker;</span><br><span class="line">    List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br><span class="line">    <span class="keyword">if</span> (!filters.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> Filter filter = filters.get(i);</span><br><span class="line">            <span class="keyword">final</span> Invoker&lt;T&gt; next = last;</span><br><span class="line">            last = <span class="keyword">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> invoker.getInterface();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> invoker.getUrl();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> invoker.isAvailable();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">                    Result result = filter.invoke(next, invocation);</span><br><span class="line">                    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> AsyncRpcResult) &#123;</span><br><span class="line">                        AsyncRpcResult asyncResult = (AsyncRpcResult) result;</span><br><span class="line">                        asyncResult.thenApplyWithContext(r -&gt; filter.onResponse(r, invoker, invocation));</span><br><span class="line">                        <span class="keyword">return</span> asyncResult;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> filter.onResponse(result, invoker, invocation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    invoker.destroy();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> invoker.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>由上述代码我们可以看到,dubbo中运用装饰者模式和责任链模式,对我们提供的服务做了一次封装,最终转换成我们需要的invoker对外暴露</li>
<li>要注意到的是,当我们的协议是registry也就是注册协议的时候,是不需要进行构建责任链的</li>
</ul>
</blockquote>
<h3 id="本地暴露"><a href="#本地暴露" class="headerlink" title="本地暴露"></a>本地暴露</h3><figure class="highlight java"><figcaption><span>InjvmProtocol</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>如果是本地暴露,则通过SPI拿到InjvmProtocol,最终通过injvm协议导出InjvmExporter</li>
</ul>
</blockquote>
<h3 id="远程暴露"><a href="#远程暴露" class="headerlink" title="远程暴露"></a>远程暴露</h3><figure class="highlight java"><figcaption><span>DubboProtocol</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       URL url = invoker.getUrl();</span><br><span class="line">       <span class="comment">// 导出服务.</span></span><br><span class="line">       String key = serviceKey(url);</span><br><span class="line">       DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">       exporterMap.put(key, exporter);</span><br><span class="line">       <span class="comment">//导出根服务以进行调度事件</span></span><br><span class="line">       Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);</span><br><span class="line">       Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">       <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">           String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">           <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                   logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"consumer ["</span> + url.getParameter(Constants.INTERFACE_KEY) +</span><br><span class="line">                           <span class="string">"], has set stubproxy support event ,but no stub methods founded."</span>));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//打开服务</span></span><br><span class="line">       openServer(url);</span><br><span class="line">       optimizeSerialization(url);</span><br><span class="line">       <span class="keyword">return</span> exporter;</span><br><span class="line">   &#125;	</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//打开服务</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// find server.</span></span><br><span class="line">       String key = url.getAddress();</span><br><span class="line">       <span class="comment">//客户端可以导出仅供服务器调用的服务</span></span><br><span class="line">       <span class="keyword">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY, <span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">           ExchangeServer server = serverMap.get(key);</span><br><span class="line">           <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                   server = serverMap.get(key);</span><br><span class="line">                   <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">//如果服务不存在,创建服务</span></span><br><span class="line">                       serverMap.put(key, createServer(url));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 服务器支持重置，与override一起使用</span></span><br><span class="line">               server.reset(url);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>在dubbo协议中,我们看到在服务导出的时候会根据配置地址,打开netty服务,也就是通过这一步,开启了RPC端口,使consumer通过TCP协议进行服务调用</li>
</ul>
</blockquote>
<h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><figure class="highlight java"><figcaption><span>RegistryProtocol</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">       <span class="comment">// url在本地导出</span></span><br><span class="line">       URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line">       <span class="comment">// 订阅覆盖数据</span></span><br><span class="line">       <span class="comment">// 同样的服务由于订阅是带有服务名称的缓存密钥，因此会导致订阅信息覆盖。</span></span><br><span class="line">       <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);</span><br><span class="line">       <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">       overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">       providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class="line">       <span class="comment">//导出invoker</span></span><br><span class="line">       <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class="line">       <span class="comment">//将url注册到注册中心</span></span><br><span class="line">       <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">       <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line">       ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class="line">               registryUrl, registeredProviderUrl);</span><br><span class="line">       <span class="comment">//判断我们是否需要推迟发布</span></span><br><span class="line">       <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">if</span> (register) &#123;</span><br><span class="line">           register(registryUrl, registeredProviderUrl);</span><br><span class="line">           providerInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Deprecated! Subscribe to override rules in 2.6.x or before.</span></span><br><span class="line">       registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">       exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">       exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line">       <span class="comment">//确保每次导出时都返回一个新的导出器实例</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;&gt;(exporter);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//真正导出服务的地方</span></span><br><span class="line">	<span class="keyword">private</span> &lt;T&gt; <span class="function">ExporterChangeableWrapper&lt;T&gt; <span class="title">doLocalExport</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker, URL providerUrl)</span> </span>&#123;</span><br><span class="line">       String key = getCacheKey(originInvoker);</span><br><span class="line">       ExporterChangeableWrapper&lt;T&gt; exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">       <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (bounds) &#123;</span><br><span class="line">               exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">               <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">final</span> Invoker&lt;?&gt; invokerDelegete = <span class="keyword">new</span> InvokerDelegate&lt;T&gt;(originInvoker, providerUrl);</span><br><span class="line">                   <span class="comment">//以dubbo协议为例,这里才是真正调用DubboProtocol.exprot的地方</span></span><br><span class="line">                   exporter = <span class="keyword">new</span> ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegete), originInvoker);</span><br><span class="line">                   bounds.put(key, exporter);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> exporter;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>大家这里可以跟进源码,会发现,在ServiceConfig中通过proxyFactory生成的Invoker的url指向的协议其实是registry,所以在ServiceConfig中protocol.exprot调用的是RegistryProtocol的exprot方法</li>
<li>在RegistryProtocol中调用了真正的远程服务暴露的方法,即DubboProtocol(以dubbo协议为例),在远程服务暴露成功后,将服务信息注册到registry上去,由此完成了一个服务的导出</li>
<li>至此Dubbo服务暴露中的大致流程已经完成了,后面将会对Dubbo如何通过ProxyFactory生成Invoker,以及Registry是如何进行注册的进行更加深入的学习</li>
</ul>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/19/2019-01-19-锁优化/">JVM 锁优化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JVM/">JVM</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JVM/">JVM</a></span><div class="content"><h1 id="什么是锁优化"><a href="#什么是锁优化" class="headerlink" title="什么是锁优化"></a>什么是锁优化</h1><blockquote>
<ul>
<li>为了线程之间更高效的共享数据,以及解决竞争问题,在JDK1.5之后,对锁进行了大量的优化,由此衍生出(自适应)自旋锁/轻量级锁/偏向级锁/锁消除/锁粗化等技术</li>
</ul>
</blockquote>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><blockquote>
<ul>
<li>锁消除是指虚拟机即时编译器在运行时,对一些代码上的同步要求,检测到是不可能存在共享数据竞争的,这时就会对锁进行清除,这里就好比我们去火车站买票需要排队,为了保证秩序,一般都会有一些围挡限制值人,但是现在不是高峰期,发现根本不需要做一些围栏来限制秩序,这个时候车站安保人员就会把围栏撤掉,这里这个围挡就相当于我们的锁,会根据实际情况来进行判断</li>
<li>锁消除主要源于逃逸分析的数据支持,如果判断一段代码中,堆上的所有数据都不会逃逸出去被其他线程访问,那么可以把它当做栈上数据来对待,认为他是线程私有的,那么就不用加锁了</li>
<li>要注意的是,不仅仅是我们在开发中手动加的锁,在有些场景中,同步代码也是普遍存在的</li>
</ul>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String s1,String s2,String s3)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> s1 + s2 + s3 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>我们知道,由于String是一个不可变类,对字符串的操作是转换成新的String对象来进行的,在jdk1.5及以前的版本,这个字符串拼接会被javac编译成</li>
</ul>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//javac编译后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String s1,String s2,String s3)</span></span>&#123;</span><br><span class="line">	StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">	sb.append(s1);</span><br><span class="line">	sb.append(s2);</span><br><span class="line">	sb.append(s3);</span><br><span class="line">   <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//StringBuffer的append方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       toStringCache = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">super</span>.append(str);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>但是我们看到StringBuffer的append方法是一个同步方法,但是在该方法中,并不需要加锁,所以在jdk1.5以后的版本, StringBuffer会被优化成StringBuilder,而StringBuilder是不加锁的</li>
</ul>
</blockquote>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><blockquote>
<ul>
<li>一般我们在开发过程中,推荐将同步块的作用域限制的尽量小,最好是只在共享数据的实际操作的作用域加锁,这样使得需要同步的操作数量尽可能小,如果存在锁竞争,那等待的线程也能够尽快拿到锁</li>
<li>在大部分情况中上述原则是正确的,但是如果一些列连续都操作都是对同一个对象进行反复的加锁解锁操作,甚至在循环中出现这样的问题,那样既是没有线程的竞争,也会频繁的触发互斥同步的操作,对性能是有巨大损耗的</li>
<li>如何解决这类问题呢,那么就是锁粗化,顾名思义,就是将细粒度的锁变成粗粒度的锁,如果虚拟机探测到有这样一系列零零碎碎的操作都对同一个对象加锁,会把这个锁同步范围扩大到整个操作序列的外部,以上面的concat方法为例,把原来每个append方法上的锁变成对concat方法的锁</li>
</ul>
</blockquote>
<h2 id="自旋锁-自适应自旋锁"><a href="#自旋锁-自适应自旋锁" class="headerlink" title="自旋锁/自适应自旋锁"></a>自旋锁/自适应自旋锁</h2><blockquote>
<p><img src="/img/自旋锁.jpg" alt="自旋锁"></p>
</blockquote>
<blockquote>
<ul>
<li>提到自旋锁,我们先回到互斥同步本身,我们知道互斥同步有个很大的问题,就是阻塞实现,挂起线程和恢复线程都是内核态的操作,这些操作会给系统并发性能带来很大的压力,而且在很多场景中,共享数据的锁定只会持续很短的时间,而为了这段时间去恢复和挂起线程是非常不值得的,所以就有了自旋锁</li>
<li>自旋锁,前提是机器有一核以上的处理器(一核的机器现在已经很少了,可以忽略这个前提),能让两个以上的线程并行执行,这个时候我们可以让后面请求锁的线程稍微等一会,看看持有锁的线程能否快速的释放这个锁,为了让线程陷入等待,就出现了自旋(说白了就是循环),在JUC包中我们可以看到AQS中出现的下面代码,就是基于CAS实现的自旋锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">	doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>自旋锁虽然避免了线程切换带来的开销,但是在处理时间上却变得更长,如果锁占用的时间很短,那自旋等待的效果就很好,如果锁占用的时间长,那么自旋的线程只会白白浪费处理器的资源,而不会做其他有用的工作,反而会带来性能上的浪费,因此,在自旋到一定时间后还没有获得锁,就会将线程挂起,自旋的默认次数是10</li>
<li>自适应自旋锁,顾名思义就是自动适配的自旋锁,它的自旋时间不在固定,而是由上一次同一个锁上的自旋时间和锁的拥有者的状态来决定的,由此可见JVM更加智能了,对于经常获得锁的,自旋的时间会尽可能的长,而对于自旋经常获取不到锁的线程,就直接挂起线程,避免资源的浪费</li>
</ul>
</blockquote>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><blockquote>
<p><img src="/img/轻量级锁.jpg" alt="轻量级锁"></p>
</blockquote>
<blockquote>
<ul>
<li>轻量级锁也是jdk1.6之后引入的新型锁机制,轻量级是相对于使用操作系统的互斥量来实现的传统锁而言,因此传统的锁机制就被称为重量级锁,这里要强调一点的是,轻量级锁不是用来代替重量级锁的,它的本意是避免在没有锁竞争的情况下,使用重量级锁造成的资源浪费</li>
<li>说到轻量级锁,首先要了解对象头的内容<a href="http://blog.leishunyu.com/2019/01/11/2019-01-11-jvm%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/">对象在JVM中的储存</a>,对象在没有进入同步块的时候,如果此同步对象没有被锁定(锁标识为”01”的状态), jvm将在栈中建立一个LockRecord的空间,用于存储当前对象MarkWord的拷贝(Displaced MarkWord),如上图所示,然后虚拟机将使用CAS操作尝试对对象头的MarkWord更新为指向LockRecord的指针,如果更新成功,则对象拥有对该对象的锁,并且将锁标识转变成”00”</li>
<li>如果更新失败了,jvm会首先检查对象的MarkWord是否指向当前的栈,如果指向当前线程的栈,则说明已经获得锁,那就可以进入同步块去执行,如果没有指向,则说明当前线程的锁已经被其他线程抢占了,如果有两条以上的线程去争夺同一个锁,那么轻量级锁就会失效,膨胀为重量级锁,锁标识的状态值也会变为”10”, MarkWord指向的就是重量级锁(互斥量的指针),后面等待锁的线程也要进入阻塞状态</li>
<li>轻量级锁解锁也是通过CAS进行的,如果对象的MarkWord仍然指向着线程的锁记录,那就用CAS把对象当前的MarkWord替换回来,如果替换成功,说明整个同步过程就完成了,如果替换失败,说明其他线程尝试获取过锁,那么在释放锁的时候还要唤起其他被挂起的线程</li>
<li>轻量级锁提升性能的依据在于,对于大部分的锁,在整个同步周期内都是不存在竞争的,这只是一个经验数据,如果没有竞争,轻量级锁使用CAS操作避免了使用互斥线程的开销,但是如果存在竞争,那么除了互斥开销外,还有CAS的开销,在有竞争的情况下,轻量级锁会比传统的重量级锁更慢</li>
</ul>
</blockquote>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><blockquote>
<p><img src="/img/偏向锁.jpg" alt="偏向锁"></p>
<ul>
<li>偏向锁和轻量级锁类似,也是对于MarkWord的一系列操作,顾名思义,偏向锁,是指偏向某一个线程的锁,偏向锁会偏向第一个获取他的线程,如果在接下来的执行当中都没有其他线程获取,那么持有偏向锁的线程将永远不用在进行同步</li>
<li>当锁第一次被对象获取时,在将锁标识为”01”,即偏向锁模式,然后使用CAS操作把线程ID记录到MarkWord中,如果更新成功,持有偏向锁的线程,每次进入同步块时都不需要重新加锁</li>
<li>当有另一个线程尝试获得锁时,偏向模式宣告结束,根据锁对象目前是否处于被锁定的状态,决定撤销偏向,还是升级到轻量级锁</li>
<li>偏向锁可以提高带有同步但是无竞争的程序性能,同样是有利有弊,如果程序中大部分锁是要被多个不同线程访问,偏向锁肯定是有负担的</li>
</ul>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/11/2019-01-11-jvm对象在内存中的存储/">JVM 对象在内存中的存储</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JVM/">JVM</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JVM/">JVM</a></span><div class="content"><h1 id="对象在内存中的存储"><a href="#对象在内存中的存储" class="headerlink" title="对象在内存中的存储"></a>对象在内存中的存储</h1><blockquote>
<ul>
<li>如图1,可以看到一个对象在JVM内存中是如何存储的</li>
</ul>
</blockquote>
<p><img src="/img/对象头1.jpg" alt="图1"></p>
<h2 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h2><blockquote>
<ul>
<li>对象头主要包括MarkWord,class指针,如果是数组还有数组的长度</li>
<li>MarkWord:包括对象的hashcode,GC分代年龄,锁状态标识,线程持有的锁,偏向线程ID,如下图<br><img src="/img/jvm32.jpg" alt="32位jvm中MarkWord"><br><img src="/img/jvm64.jpg" alt="64位jvm中MarkWord"></li>
<li>如上图所示,我们可以发现对象年龄分代为4bit,最大值也就是1111-&gt;15,所以在GC回收的时候,年龄超过15的对象会被加入老年代<a href="http://blog.leishunyu.com/2019/01/10/2019-01-10-jvm%E6%96%B0%E7%94%9F%E4%BB%A3:%E8%80%81%E5%B9%B4%E4%BB%A3/">JVM新生代/老年代</a></li>
<li>上图锁相关的标识将在后面的锁优化进行展开</li>
</ul>
</blockquote>
<h2 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h2><blockquote>
<ul>
<li>对象真正存储的有效数据,各种字段内容</li>
</ul>
</blockquote>
<h2 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h2><blockquote>
<ul>
<li>不是必然存储,hotspot的自动内存管理要求对象大小必须是8字节的整数倍,而对象头正好是8字节的整数倍,所有实例数据部分如果没有对齐时,就需要通过对齐来自动填充</li>
</ul>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/10/2019-01-10-jvm新生代:老年代/">JVM 新生代/老年代</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JVM/">JVM</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JVM/">JVM</a></span><div class="content"><h1 id="JVM-GC-流程图"><a href="#JVM-GC-流程图" class="headerlink" title="JVM GC 流程图"></a>JVM GC 流程图</h1><p><img src="/img/新生代-老年代.jpg" alt="图1"></p>
<h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><blockquote>
<ul>
<li>主要是用来存放新生对象,一般占据对的1/3,由于频繁的创建对象,所以新生代会频繁的触发MinorGC进行垃圾回收</li>
<li>新生代又分为Eden,SurvivorTo,SurvivorForm三个区</li>
<li>Eden区:JAVA新对象的出生地(如果新创建的对象占用内存很大,就直接分配到老年代),当Eden内存不够时,将触发一次MinorGC,对新生代进行一次回收,Eden占整个新生代的80%</li>
<li>SurvivorTo(SurvivorForm):保留了一次MinorGC的幸存者,占用新生代的10%</li>
<li>SurvivorForm(SurvivorTo):上一次MinorGC的幸存者,将和Eden一次参与这一次MinorGC扫描,占用新生代的10%</li>
<li>MinorGC的过程如果这次GC还幸存下来的对象,将复制到SurvivorTo中, SurvivorTo变成SurvivorForm,SurvivorForm变成SurvivorTo,并将对象年龄+1,这里就采用了标记-复制算法(由于新生代中都是朝生夕灭),如果发现SurvivorForm中的对象达到了老年标准,就把对象移动到老年代,一般年龄默认是15</li>
</ul>
</blockquote>
<h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><blockquote>
<ul>
<li>老年代主要存放的对象都比较稳定,一般存放的是应用程序中生命周期长的对象,当然也不排除有些朝生夕死的大对象,所以FullGC不会频繁的执行</li>
<li>一般进行FullGC之前都会触发一次MinorGC,使得新对象晋升到老年代使得老年代内存不足而触发FullGC,或者是大对象直接进入老年代导致老年代内存不足而触发</li>
<li>FullGC采用标记-整理算法,因为每次GC后会造成大量的内存碎片,造成内存的不连续性,所以FullGC首先会先扫描一遍老年代,标记存活和要回收的对象,然后在进行整理,是存活的对象都移动到一端,最后直接对端边界的内存(回收对象)进行回收</li>
<li>如果当老年代也装不下的时候就会抛出Out of Memeory(OOM)异常</li>
</ul>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/10/2019-01-10-mysql innodb 表相关/">mysql innodb 表相关</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/数据库原理/">数据库原理</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MYSQL/">MYSQL</a></span><div class="content"><h1 id="innodb-表相关知识导图"><a href="#innodb-表相关知识导图" class="headerlink" title="innodb 表相关知识导图"></a>innodb 表相关知识导图</h1><p><img src="/img/表.jpg" alt=""></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/09/2019-01-09-jvm类加载器/">JVM类加载器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JVM/">JVM</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JVM/">JVM</a></span><div class="content"><h2 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器"></a>什么是类加载器</h2><blockquote>
<p>虚拟机用来实现让应用程序自己决定如何去获取所需要的类</p>
</blockquote>
<h2 id="类和类加载器"><a href="#类和类加载器" class="headerlink" title="类和类加载器"></a>类和类加载器</h2><blockquote>
<ul>
<li>对于任何一个类,都需要由加载他的类加载器和这个类本身一起确定其在java虚拟机中的唯一性,每个类加载器,都拥有一个独立的类名称空间.也就是比较两个类时候”相等”,只有在这两个类由同一个类加载器加载的前提下,否则两个类来源于同一个class文件,被同一个虚拟机加载,只要这两个类的加载器不同,那这两个类必然不相等</li>
<li>常见的方法有Class对象的equals(),isAssignableFrom(),isInstance()方法,也包括使用instanceof关键字的返回结果</li>
</ul>
</blockquote>
<blockquote>
<h3 id="从虚拟机的的角度讲-只存在两种不同的类加载器"><a href="#从虚拟机的的角度讲-只存在两种不同的类加载器" class="headerlink" title="从虚拟机的的角度讲,只存在两种不同的类加载器"></a>从虚拟机的的角度讲,只存在两种不同的类加载器</h3><ul>
<li>一种是启动类加载器(bootstrap classloader),这个类加载器使用C++实现,是虚拟机自身的一部分,无法直接被java程序引用</li>
<li>一种就是所有其他的类加载器,这类加载器都有java实现,独立于虚拟机外部,并且全部集成java.lang.ClassLoader</li>
</ul>
</blockquote>
<h2 id="类加载模型"><a href="#类加载模型" class="headerlink" title="类加载模型"></a>类加载模型</h2><blockquote>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul>
<li>模型层级: 启动类加载器(bootstrap classloader) &lt;- 拓展类加载器(Extension classloader):负责加载&lt;JAVA_HOME&gt;\lib\ext目录中或者被java.ext.dirs系统变量实现的所有类库 &lt;- 应用程序类加载器(Application classloader):开发者可以直接使用的 &lt;- 自定义类加载器</li>
<li>双亲委派模型要求除了顶层的启动类加载器外,其余的类都应当有自己的父类加载器,这里类加载器之间父子关系一般不会用继承的方式,而都是使用组合关系来复用父加载器的代码<br>工作过程:如果一个类加载器收到了类加载请求,它首先不会自己去尝试加载这个类,而是会把这个请求委派给父类加载器去完成,每一个层次的类加载器都是如此,因此所有加载请求最终都应该传送到顶层的启动类加载器中,只有当父加载器反馈自己无法完成这个请求的时候(他的搜索范围没有找到所需要的类),子加载器才会尝试自己去加载</li>
<li>参照ClassLoader中的代码</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先检查请求的类是否被加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// 如果父类加载器抛出ClassNotFoundException 说明父类无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果没有在父类找到该类</span></span><br><span class="line">                    <span class="comment">// 调用自身的findClass</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这是定义的类加载器;记录统计数据</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><ul>
<li>在java中大部分类加载器都遵循双亲委派模型,但是有两种场景会破坏双亲委派:</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>1.SPI对资源进行集中管理的时候,这时候采用了一种不太优雅的设计线程上线文类加载器(Thread Context ClassLoader),这个类加载器可以用过java.lang.Thread类setContextClassLoader方法进行设置,如果创建的线程还未设置,它将会从父线程集成一个,如果在应用程序全局范围内没有设置过的话,那么这个类加载器默认就是应用程序类加载器,这样就可以实现父类加载器去请求子类加载器,这块在之前dubbo spi中有做说明<br><a href="http://blog.leishunyu.com/2018/12/05/2018-12-05-Dubbo%20SPI%20%E6%9C%BA%E5%88%B6/">Dubbo SPI</a></p>
</li>
<li><p>2.在OSGI中实现热部署,模块热部署这些情况下会出现更复杂的网状结构</p>
</li>
<li>3.最后要注意的就是这两种类加载模型都不是强一致性的约束</li>
</ul>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/07/2019-01-07-jvm学习笔记/">JVM学习笔记(持续更新)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JVM/">JVM</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JVM/">JVM</a></span><div class="content"><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM:"></a>JVM:</h2><ul>
<li>程序计数器:线程私有,切换字节码来进行不同命令的执行,每个线程独立执行</li>
<li>虚拟机栈:存放编译期可知的基本数据类型和对象引用(对象指针),线程私有</li>
<li>本地方法栈:虚拟机使用到的native方法的服务,和虚拟机栈类型.由虚拟机厂商自己实现</li>
<li>堆:线程共享,管理对象,GC的场所(新生代,老生代)</li>
<li>方法区:存储虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码(类方法),线程共享</li>
<li>运行时常量池:方法区的一部分,对于常量池没有具体限制的规范,String则是一个很好的例子</li>
<li>直接内存:不属于JVM,即机器的内存</li>
</ul>
<h2 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配:"></a>对象内存分配:</h2><ul>
<li>对象头:对象运行时的数据,hashcode,GC分代年龄,锁状态标识,线程持有的锁,偏向线程ID,偏向时间戳,类型指针(指向元数据的指针,并不是所有对象都有类型指针,如果是数组对象,还应该有存储数据长度的一块数据)</li>
<li>实例数据:对象真正存储的有效数据,各种字段内容</li>
<li>对齐填充:不是必然存储,hotspot的自动内存管理要求对象大小必须是8字节的整数倍,而对象头正好是8字节的整数倍,所有实例数据部分如果没有对齐时,就需要通过对齐来自动填充</li>
</ul>
<h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法:"></a>GC算法:</h2><ul>
<li>引用计数算法:给对象中添加一个引用计数器,当一个地方引用它时,计时器就加1,当引用失效时,计数器就减1,任何对象的计数器为0时就是不可能再被使用了,但是如果出现了互相引用,但是该对象已经没有被其他任何对象引用,就会导致计数器永远不为0,导致无法gc</li>
<li>可达性分析算法:通过GC Root作为起点,当一个对象到GC Root没有任何引用链相关时,则证明该对象不可用,将被判断对象不可用<h2 id="GCRoot的对象包括"><a href="#GCRoot的对象包括" class="headerlink" title="GCRoot的对象包括:"></a>GCRoot的对象包括:</h2></li>
<li>jvm中引用的对象(int,long,boolean,float,double,byte,char,reference的数据)</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象(final 的常量值)</li>
<li>本地方法栈JNI的应用对象(即native方法)<h2 id="JAVA应用"><a href="#JAVA应用" class="headerlink" title="JAVA应用:"></a>JAVA应用:</h2></li>
<li>强引用:Object obj = new Object()这类引用,只要强引用还存在,垃圾回收器永远不会回收掉被引用的对象</li>
<li>软引用:用来描述一些还有用但并非必须的对象,对于软引用关联着的对象,在系统将要发生内存溢出异常之前,会将这些对象列入回收范围,并进行二次回收,如果这次回收还是没有足够的内存,才会出现内存溢出的异常,通过SoftReference实现</li>
<li>弱引用:用来描述非必须对象,强度比软引用要更弱,被弱引用关联的对象只能存活到下一次垃圾回收之前,当垃圾回收器开始工作时,无论当前内存是否足够,都会被回收,通过WeakReference实现</li>
<li>虚应用:最弱的一种引用关系,一个对象是否设置虚应用,完全不会影响其生存时间,也无法通过虚引用来取得一个对象的实例,设置虚引用唯一的目的就是能在这个对象被回收的时候拿到一个系统通知,通过PhantomReference实现</li>
</ul>
<h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机:"></a>类加载时机:</h2><pre><code>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载
</code></pre><blockquote>
<p>有且只有5种情况会必须进行初始化</p>
</blockquote>
<blockquote>
<ul>
<li>遇到new,getstatic,putstatic,或者invokestatic这4个字节指令时,如果类没有进行初始化,则需要先触发其初始化,生成这4条指令的最常见的java代码场景就是:使用new关键字实例化对象的时候,读取或设置一个类的静态字段(被final修饰,已经在编译期把结果放入常量池的静态字段除外)的时候,以及调用一个类的静态方法的时候</li>
<li>使用反射包中的方法对类进行反射调用的时候,如果类没有进行过初始化,则需要先触发其初始化</li>
<li>当初始化一个类的时候,如果发现其父类还没有进行初始化的时候,则需要先触发其父类的初始化(如果是接口,并不要求父接口完全都完成了实例化)</li>
<li>当虚拟机启动时,用户需要指定一个要执行的主类(包含main()方法的那个类),虚拟机会先初始化这个主类</li>
<li>当使用jdk1.7的动态语言支持时,如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄,并且这个句柄的类没有进行初始化,则需要先进行初始化</li>
</ul>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/02/2019-01-02-mysql redo log/">mysql redo log</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/数据库原理/">数据库原理</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MYSQL/">MYSQL</a></span><div class="content"><h1 id="redo-log-文件"><a href="#redo-log-文件" class="headerlink" title="redo log 文件"></a>redo log 文件</h1><h2 id="什么是redo-log"><a href="#什么是redo-log" class="headerlink" title="什么是redo log"></a>什么是redo log</h2><blockquote>
<ul>
<li>记录了对MYSQL数据库innodb存储引擎,记录了innodb存储引擎的事务日志,用于恢复数据。每个innodb存储引擎至少有一个redo log文件组,每个文件组中至少有两个redo log文件,每个文件大小一致,并以循环写入的方式运行.并且redo log不是直接写到磁盘,是先写入redo log缓存,在刷盘到磁盘,当两个文件都写满的时候,会进行checkpoint,将文件1的内容抹除,如图<br><img src="/img/redolog.jpg" alt=""></li>
</ul>
</blockquote>
<h2 id="redo-log-和-binlog的区别"><a href="#redo-log-和-binlog的区别" class="headerlink" title="redo log 和 binlog的区别"></a>redo log 和 binlog的区别</h2><h3 id="这里可能大家会有疑问-binlog可以恢复-那么要redo-log有什么意义呢"><a href="#这里可能大家会有疑问-binlog可以恢复-那么要redo-log有什么意义呢" class="headerlink" title="这里可能大家会有疑问,binlog可以恢复,那么要redo log有什么意义呢"></a>这里可能大家会有疑问,binlog可以恢复,那么要redo log有什么意义呢</h3><blockquote>
<ul>
<li>redo log 是innodb引擎特有的,binlog是mysql的server层实现的,所有引擎都可以使用</li>
<li>redo log 是物理日志,记录了在某个数据页的修改,binlog是逻辑日志,记录的是这条记录的修改逻辑</li>
<li>redo log 是循环写的,空间固定会用完,binlog是可以追加写入的,”追加写”是指binlog文件写到一定大小后会切换到下一个,并不会覆盖以前的日志</li>
<li>redo log 的大小不宜设置的过大或者过小,过小的话会导致频繁的checkpoint导致性能抖动,太大则恢复会需要更长的时间</li>
</ul>
</blockquote>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><blockquote>
<ul>
<li>为了保证恢复数据时的状态准确性,维护逻辑一致性,采用两阶段提交,例如一次更新数据,如图<br><img src="/img/两阶段提交.jpg" alt=""></li>
<li>根据binlog的特性,我们可以知道binlog是在事务提交前写入,如果事务还未提交的时候,这个时候binlog已经写入了,但是数据库发生了异常宕机,那么根据binlog来恢复,就会把未提交的事务给恢复到库中,造成脏数据,而采用两阶段提交,这个时候我们看到redo log处于prepare阶段,binlog已经写了日志<br>则可以对未提交事务的脏数据做处理,防止恢复的时候出现脏数据</li>
<li>如果redo log 里面的事务只有完整的prepare,则判断对应事务binlog是否完整存在,如果是,则提交事务,如果不是回归事务</li>
</ul>
</blockquote>
<h2 id="redo-log-的写入"><a href="#redo-log-的写入" class="headerlink" title="redo log 的写入"></a>redo log 的写入</h2><blockquote>
<ul>
<li>通过设置参数innodb_flush_log_at_trx_commit的值来控制将缓存中的redo log写入磁盘,0代表提交事务时,不将redo log写入磁盘,而是等每次主线程刷新,1和2的区别在于,1表示在commit的时候将redo log从缓存中同步到磁盘,即伴有fsync的调用,2表示将redo log异步写到磁盘,即写到文件系统的缓存中,因此不能完全保证执行commit的时候会一定写入磁盘,为了保证事务的ACID中的持久性,必须将此参数设置为1,也就是每当有事务提交时,必须保证日志写入磁盘</li>
<li>这里要注意,如果有两个事务,如果事务A提交,事务B只写了redo log那么事务B的redo log也会被刷到磁盘上</li>
</ul>
</blockquote>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By 怀风</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>