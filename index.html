<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="javaer"><meta name="keywords" content=""><meta name="author" content="怀风,undefined"><meta name="copyright" content="怀风"><title>那些疯狂到以为自己能够改变世界的人才能真正改变世界 | Maple</title><link rel="shortcut icon" href="https://pic.52112.com/icon/256/20190107/27483/1369601.png"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/29188508?s=400&amp;u=f3fc60d5b158f5d5a25e5d7a5a26ce394a41435f&amp;v=4"></div><div class="author-info__name text-center">怀风</div><div class="author-info__description text-center">javaer</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">18</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div></div></div><nav class="no-bg" id="nav" style="background-image: url(true)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Maple</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/archives/">首页</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="site-info"><div id="site-title">Maple</div><div id="site-sub-title">那些疯狂到以为自己能够改变世界的人才能真正改变世界</div><div id="site-social-icons"> <a class="social-icon" href="https://github.com/Leishunyu/" target="_blank"><i class="fa fa-github"></i></a><a class="social-icon" href="https://weibo.com/u/2394913967" target="_blank"><i class="fa fa-weibo"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/27/2019-06-27-阿里面试经历/">记阿里面试经历</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/分享/">分享</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/分享/">分享</a></span><div class="content"><h1 id="阿里面试经历"><a href="#阿里面试经历" class="headerlink" title="阿里面试经历"></a>阿里面试经历</h1><h2 id="第一次面试"><a href="#第一次面试" class="headerlink" title="第一次面试"></a>第一次面试</h2><h3 id="盒马一面"><a href="#盒马一面" class="headerlink" title="盒马一面"></a>盒马一面</h3><blockquote>
<ul>
<li>三月中旬,接到盒马的电话面试邀请,约定在一周后的晚上7点进行第一轮电面,这次面试大概一个半小时,面试官先是问了项目,讲一讲最近的项目,然后如何设计的,在设计中遇到了什么,并且提出一些他对于这个设计的一些疑问,项目问完后,问的是技术,技术点主要是以下几点:</li>
<li>面试官:平时项目中有用到哪些中间件,能不能介绍下.我的回答:Dubbo,RocketMQ,Redis等等,但是RocketMQ,Redis这些仅仅只是应用,没有看过源码,对于其只是简单了解,Dubbo我就比较熟,现在也活跃在社区为Dubbo做一些贡献</li>
<li>面试官:如果让你自己实现RPC,你会怎么样去做?我的回答:注册中心(zk,etcd,nacos,redis),然后一个provider一个consumer,要实现网络通信,就需要netty/mina这种中间件来做网络通信,巴拉巴拉</li>
<li>面试官:那讲一下Dubbo你最熟悉的模块吧.我的回答:从dubbo的架构到服务注册发现调用,以及dubbo的spi机制,集群容错策略等等</li>
<li>面试官:对于NIO有了解过吗.我的回答:有,但是只是很简单的了解,没有深入阅读源码,这块还是不做展开吧(netty和NIO这块是我的弱项,问道这个真的很头大)</li>
<li>面试官:java的类加载机制和内存模型能够讲一讲吗.这个问题大概就不用展开了</li>
<li>面试官:介绍一下tcp/ip协议.我的回答:三次握手,四次挥手(这块由于当时紧张,就很简单的说了下,然后给面试官说突然有的反应不过来了,这个问题还是算了吧,面试官也就没有继续追问)</li>
<li>面试官:spring和mybatis有了解过吗.我的回答:有了解,但是没有深入源码,只能大概聊一下,没有dubbo那么熟(面试官也没有技术追问)</li>
<li>面试官:如何创建多线程,如何让多个线程在同一时间执行.这个问题也就不用展开了</li>
<li>后来就是mysql的一些索引优化,mysql的基础架构等等问题,最后面试官问我,有没有什么问题,我就问了下如果有下一面大概是什么时候有通知,面试官说最近忙,正常的话大概是一周左右,我说好的,就这样一面结束</li>
</ul>
</blockquote>
<h3 id="盒马二面"><a href="#盒马二面" class="headerlink" title="盒马二面"></a>盒马二面</h3><blockquote>
<ul>
<li>周六在回家的公交车,二面面试官打来了电话,准备进行二面,当时在车上,我就说一个小时后后到家在聊,一个小时后回到家里,如约进行了二面,时间接近40分钟</li>
<li>二面主要就是讲项目,我这里主要讲的是预售库存,主要涉及到高并发设计,采用缓存如何解决数据不一致问题来描述,项目讲完就是问职业规划这些的,然后二面结束</li>
</ul>
</blockquote>
<h3 id="盒马三面"><a href="#盒马三面" class="headerlink" title="盒马三面"></a>盒马三面</h3><blockquote>
<ul>
<li>盒马三面依旧是电话面试,面试时长和二面差不多,内容也比较相似,都是问项目,职业规划,但是在此基础上,还问了这样的业务场景有助于解决一个什么样的场景,对当前行业又如何的影响和后续能做的优化,把技术跟业务更紧密的结合,并且考察如何从技术层面推动业务,最后面试官问我如果是上嘉编制(盒马旗下公司,但是不属于阿里集团编制)考不考虑,我当时回答不考虑,毕竟对于阿里来说还是外包,三面也就到此结束</li>
<li>后来二面面试官给我打电话,告诉我,看中我的潜力,让我可以在冲一下阿里其他的BU,这次面试给的P5+,觉得他老板的要求还是比较严格,噼里啪啦说了一堆,也很感谢二面的面试官,在面试评价中给我的评价比较好,也让我在接下来的面试更有优势</li>
</ul>
</blockquote>
<h2 id="第二次面试"><a href="#第二次面试" class="headerlink" title="第二次面试"></a>第二次面试</h2><blockquote>
<ul>
<li>第二次面试是找前同事推得业务平台事业部-营销平台,大概在第一次面试后两个月,中间被菜鸟的人卡住卡了大概一个月,很蛋疼</li>
</ul>
</blockquote>
<h3 id="阿里简历评估面试"><a href="#阿里简历评估面试" class="headerlink" title="阿里简历评估面试"></a>阿里简历评估面试</h3><blockquote>
<ul>
<li>简历评估面试大概问题和盒马一面类似,但是即便我说redis只是简单应用,也还是问了我redis的几种数据结构和特性,分布式锁用redis的什么数据结构实现,然后还有threadLocal</li>
</ul>
</blockquote>
<h3 id="阿里在线笔试评估"><a href="#阿里在线笔试评估" class="headerlink" title="阿里在线笔试评估"></a>阿里在线笔试评估</h3><blockquote>
<ul>
<li>两道在线编码题,最开始第一道让我手写雪花算法,写不出来,后面面试官就给我换了</li>
<li>有3个独立的线程，一个只会输出A，一个只会输出L，一个只会输出I,在三个线程同时启动的情况下，请用合理的方式让他们按顺序打印ALIALI</li>
<li>请用java实现以下shell脚本的功能<br>cat /home/admin/logs/webx.log | grep “Login” | uniq -c | sort -nr</li>
<li>这两道题既是考察多线程和io</li>
</ul>
</blockquote>
<h3 id="阿里一面"><a href="#阿里一面" class="headerlink" title="阿里一面"></a>阿里一面</h3><blockquote>
<ul>
<li>由于中间阿里大部分BU锁了P7以下的hc,我的面试流程就被搁浅了,当时心想着估计今年够呛了,就在一个周五的中午,接到了一面电话</li>
<li>一面内容和简历面差不多,还问了为dubbo贡献了什么代码,学习到了什么,怎么发现这些问题的,我就巴拉巴拉,另外还有就是如何快速定位问题,一台机器突然cpu和内存都满了,怎么样快速解决,这个时候考察的不是如果做gc调优,是如何快速进行问题修复</li>
<li>然后一面就愉快地结束了</li>
</ul>
</blockquote>
<h3 id="阿里二面"><a href="#阿里二面" class="headerlink" title="阿里二面"></a>阿里二面</h3><blockquote>
<ul>
<li>阿里二面的时候是一个小姐姐,她应该就是我入职后的直属leader,她在一面的当天晚上就给我打来了电话,因为是小姐姐,最开始以为是HR,因为小姐姐的问题也都是职业规范,为什么离职,之前在公司怎么学习的,之前公司氛围很好为什么离职,后来又问我在dubbo贡献中学到了什么,自己觉得自己有什么优势,没有问一个技术,后来我问她,这个面试流程怎么回事,突然就hr面了吗,她说她不是hr,我说那怎么不问技术啊,比较惊讶, 她就告诉我说,前面的面试官已经问过技术了啊,大概聊一聊其实就知道了,就说我还不错,然后我问她如果又下一面是啥时候,她说大概一周左右吧,大老板比较忙</li>
</ul>
</blockquote>
<h3 id="阿里三面"><a href="#阿里三面" class="headerlink" title="阿里三面"></a>阿里三面</h3><blockquote>
<ul>
<li>过了周末,周日早上接到阿里hr小姐姐的面试邀约,周三早上在西溪园区进行现场终面,这一刻终于来了,准备好了阿里的入园前准备,一大早就去西溪园区面试了,这次面试的大佬也就是我们那个部门的CTO了</li>
<li>面试首先自我介绍,然后讲述业务场景,为什么要这么做,然后这么做解决了什么问题,然后自己在项目中负责了什么,面试前,面试官告诉我说,一定不要紧张,他问的问题也许会有些刁钻,但是按照自己的想法,想清楚后回答就好了,不一定有正确答案,然后我依旧对之前的项目进行了架构描述,然后说自己重构后的架构,解决了什么问题,带来了怎么样的成果</li>
<li>中途面试官说他去上个厕所,给我出了两个题目,让我在墙上画,一个是之前的架构我该如何优化,另一个是一个阶乘的两种写法(递归和非递归),阶乘题当时只写了一种,后来发现问题是自己没有做防御式编程,这个是不够细心,另外就是架构上后续优化,提出了可以在进行DDD上的实践</li>
<li>最后面试官问我职业规划,然后离职原因这些,就和之前面试如出一辙了,面试大概持续了一个半小时,最后面试官给我介绍了我现在面试的是经济体解决方案这个部门,主要是负责从0到1的一些业务打包,为集团其他BU提供开箱即用的SDK</li>
</ul>
</blockquote>
<h3 id="阿里HR面"><a href="#阿里HR面" class="headerlink" title="阿里HR面"></a>阿里HR面</h3><blockquote>
<ul>
<li>当天下午,阿里的hr又打电话约我第二天早上的HRG的视频面试</li>
<li>HRG的是面试大概就是为什么离职,职业规划,自己觉得自己的优势什么的,薪资待遇这些,大概时间半个小时,很快就结束了</li>
</ul>
</blockquote>
<h3 id="收到Offer"><a href="#收到Offer" class="headerlink" title="收到Offer"></a>收到Offer</h3><blockquote>
<ul>
<li>由于HRG面试是端午前,过了端午的星期一早上,HRG打来了电话,说我通过了面试,跟我讲了薪资和福利待遇,就愉快地接到Offer了</li>
</ul>
</blockquote>
<h3 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h3><blockquote>
<ul>
<li>这两次阿里面试,其实可以看到阿里对于框架原理以及基础的比重非常高,不是背背面试题就能挺过去的</li>
<li>另外对于业务上,阿里也喜欢问一些高并发的问题,并且如何解决大流量,保证系统可用性,然后以及架构的优化</li>
<li>最后就是阿里很看重候选人的职业规划,我们需要对今后的职业发展有个很清晰的规划</li>
<li>面试基础准备,这里有一份之前我的老大之一(现在在网易考拉)当时为我们分享的他这些年来认为java基础比较重要的地方,当然也是面试阿里必须要准备的一些知识点</li>
<li><img src="/img/Java基础.jpg" alt="java基础"></li>
<li><a href="/img/Java基础.pdf">图片pdf的下载地址</a></li>
</ul>
</blockquote>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><blockquote>
<ul>
<li>最后要感谢在我毕业后到面上至今给我帮助的朋友同事,如果没有你们用自己亲身经历踩过的坑的分享,给我一些很关键节点上的方向,我也不会拿到阿里的offer,感谢身边的所有人</li>
</ul>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/05/27/2019-05-27-Dubbo本地服务暴露的一些坑/">Dubbo本地服务暴露的一些坑</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DUBBO/">DUBBO</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/DUBBO/">DUBBO</a></span><div class="content"><h1 id="Dubbo本地服务暴露的一些坑"><a href="#Dubbo本地服务暴露的一些坑" class="headerlink" title="Dubbo本地服务暴露的一些坑"></a>Dubbo本地服务暴露的一些坑</h1><h2 id="本地暴露"><a href="#本地暴露" class="headerlink" title="本地暴露"></a>本地暴露</h2><blockquote>
<ul>
<li>Dubbo本地服务暴露,实在暴露远程服务之前会进行本地服务暴露,避免provider和consumer在同一容器内,进行不必要的网络开销,即本地调用对应protocol为injvm</li>
<li>而在Dubbo的服务暴露中,应该默认是无论什么场景,都应该进行本地服务的暴露,但是实际情况却并不是这样,参照该issue<a href="https://github.com/apache/dubbo/issues/3638" target="_blank" rel="noopener">injvm and local call</a>,本篇也主要对该issue的问题</li>
</ul>
</blockquote>
<h2 id="ServiceConfig中exportLocal的问题"><a href="#ServiceConfig中exportLocal的问题" class="headerlink" title="ServiceConfig中exportLocal的问题"></a>ServiceConfig中exportLocal的问题</h2><blockquote>
<ul>
<li><img src="/img/dubbo-localcall.jpg" alt=""></li>
<li>如图,可以看到框中红线代码对我们配置中的协议做了判断,如果不是injvm协议,则构建一个injvm的的URL进行本地服务的暴露,那么问题来了,如果我们指定了injvm协议的话,这块将不会执行,那也就无法进行本地服务的暴露了,当然我们一般不会使用injvm协议进行本地调用,所以从dubbo开源到现在,这个问题也就没有被大家所发现,去掉这个判断逻辑便解决问题</li>
<li>这块代码曾经在学习服务暴露的时候有过疑问,但是没有过于深究,直到看到这个issue的时候才恍然大悟,其实也反映出自己在学习框架源码过程中,对于一些细节有疑问但是却有惯性思维,觉得那么多人都看过这里,是自己理解错了吧的想法没有去仔细思考,学习还是需要带着自己的思想抱着一股打破砂锅问到底的劲才行</li>
</ul>
</blockquote>
<h2 id="ServiceConfig中doExportUrls的问题"><a href="#ServiceConfig中doExportUrls的问题" class="headerlink" title="ServiceConfig中doExportUrls的问题"></a>ServiceConfig中doExportUrls的问题</h2><blockquote>
<ul>
<li><img src="/img/dubbo-localregistry.jpg" alt=""></li>
<li>如图,可以看到在往注册中心注册服务的时候,新增了如果是injvm协议,则跳出循环的判断,因为dubbo支持多注册中心,所以该判断不能再服务注册前过滤,在历史版本中,如果采用injvm协议,也会使该协议注册到registry上,这个显然是没有必要的</li>
</ul>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<ul>
<li>这两个问题都是很细微的问题,但是也反应出我们在平时编码中对细节的把控,已经对问题考虑的全面性,在学习的时候也同样要把控细节,不是说看看别人博客怎么写,自己就怎么想,源码学习应该有自己的思索</li>
</ul>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/27/2019-03-27-Netty -HashedWheelTimer时间轮学习/">Netty HashedWheelTimer时间轮源码学习</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Netty/">Netty</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Netty/">Netty</a></span><div class="content"><h1 id="HashedWheelTimer时间轮源码学习"><a href="#HashedWheelTimer时间轮源码学习" class="headerlink" title="HashedWheelTimer时间轮源码学习"></a>HashedWheelTimer时间轮源码学习</h1><h2 id="HashedWheelTimer时间轮的简介"><a href="#HashedWheelTimer时间轮的简介" class="headerlink" title="HashedWheelTimer时间轮的简介"></a>HashedWheelTimer时间轮的简介</h2><blockquote>
<ul>
<li>HashedWheelTimer是Netty中的一个基础工具类,主要用来高效处理大量定时任务,且任务对时间精度要求相对不高,  比如链接超时管理等场景, 缺点是, 内存占用相对较高。但是在使用时要注意任务里不要有太耗时的操作, 否则会阻塞Worker线程, 导致tick不准</li>
<li>HashedWheelTimer主要还是一个DelayQueue和一个时间轮算法组合</li>
<li>如下图,可以看到HashedWheelTimer是由一个环形链表及数组构成<br><img src="https://images2018.cnblogs.com/blog/600147/201712/600147-20171202215241038-1756544686.png" alt="HashedWheelTimer原理图"></li>
<li>如下图,可以解释为什么在使用HashedWheelTimer不能有太耗时的操作,因为worker的执行时,任务是串行的<br><img src="/img/时间轮1.jpg" alt="HashedWheelTimer执行过程"></li>
<li>如下图,可以看到HashedWheelTimer是由HashedWheelBucket数组, HashedWheelTimeout链表和工作线程Worker组成,所以我们的源码分析也主要从这几个类入手<br><img src="/img/时间轮2.jpg" alt="HashedWheelTimer类图"></li>
</ul>
</blockquote>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="HashedWheelTimer中的基本字段"><a href="#HashedWheelTimer中的基本字段" class="headerlink" title="HashedWheelTimer中的基本字段"></a>HashedWheelTimer中的基本字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例计数器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger INSTANCE_COUNTER = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">   <span class="comment">//实例过多警告值</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicBoolean WARNED_TOO_MANY_INSTANCES = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">   <span class="comment">//实际数量限制</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTANCE_COUNT_LIMIT = <span class="number">64</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MILLISECOND_NANOS = TimeUnit.MILLISECONDS.toNanos(<span class="number">1</span>);</span><br><span class="line">   <span class="comment">//资源泄漏检测器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ResourceLeakDetector&lt;HashedWheelTimer&gt; leakDetector = ResourceLeakDetectorFactory.instance()</span><br><span class="line">           .newResourceLeakDetector(HashedWheelTimer.class, <span class="number">1</span>);</span><br><span class="line">   <span class="comment">//工作线程状态更新</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimer&gt; WORKER_STATE_UPDATER =</span><br><span class="line">           AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimer.class, <span class="string">"workerState"</span>);</span><br><span class="line">   <span class="comment">//泄漏值</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ResourceLeakTracker&lt;HashedWheelTimer&gt; leak;</span><br><span class="line">   <span class="comment">//工作对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">   <span class="comment">//工作线程</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Thread workerThread;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_INIT = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_STARTED = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_SHUTDOWN = <span class="number">2</span>;</span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"unused"</span>, <span class="string">"FieldMayBeFinal"</span> &#125;)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> workerState; <span class="comment">// 0 - init, 1 - started, 2 - shut down</span></span><br><span class="line">   <span class="comment">//tick的时长，也就是指针多久转一格</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> tickDuration;</span><br><span class="line">   <span class="comment">//时间轮数组</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelBucket[] wheel;</span><br><span class="line">   <span class="comment">// 这是一个标示符，用来快速计算任务应该呆的格子。</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mask;</span><br><span class="line">   <span class="comment">//开始时间已初始化</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startTimeInitialized = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">   <span class="comment">//任务队列</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;HashedWheelTimeout&gt; timeouts = PlatformDependent.newMpscQueue();</span><br><span class="line">   <span class="comment">//关闭的任务队列</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;HashedWheelTimeout&gt; cancelledTimeouts = PlatformDependent.newMpscQueue();</span><br><span class="line">   <span class="comment">//挂起超时次数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong pendingTimeouts = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">   <span class="comment">//最大挂起超时次数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxPendingTimeouts;</span><br><span class="line">   <span class="comment">//开始时间</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> startTime;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>从以上源码中我们可以大概了解到一个时间轮的执行依赖哪些条件,其中我们的任务都是基于Queue来实现的,但是这里我们要注意的是,这里的Queue是基于jctools中的Queue,以此得到更高的性能</li>
<li>mask标识符用来做位运算</li>
<li>通过原子类来保证并发情况下的一致性</li>
<li>这里我觉得值得我们学习的地方,是此处引用了资源泄露检测器,当资源超过64的时候就会进行告警,在细节方面netty考虑的非常全面,这个也是我们在平时编码的时需要学习的</li>
</ul>
</blockquote>
<h3 id="HashedWheelTimer构造方法"><a href="#HashedWheelTimer构造方法" class="headerlink" title="HashedWheelTimer构造方法"></a>HashedWheelTimer构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           ThreadFactory threadFactory, // 用来创建worker线程</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">long</span> tickDuration,// tick的时长，也就是指针多久转一格</span></span></span><br><span class="line"><span class="function"><span class="params">           TimeUnit unit, // tickDuration的时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> ticksPerWheel, // 一圈有几格</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">boolean</span> leakDetection, // 是否开启内存泄露检测</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">long</span> maxPendingTimeouts  //最大挂起超时次数</span></span></span><br><span class="line"><span class="function"><span class="params">   )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (threadFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"threadFactory"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (unit == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"unit"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (tickDuration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"tickDuration must be greater than 0: "</span> + tickDuration);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"ticksPerWheel must be greater than 0: "</span> + ticksPerWheel);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将ticksPerWheel标准化为2的幂并初始化轮子.</span></span><br><span class="line">       wheel = createWheel(ticksPerWheel);</span><br><span class="line">       <span class="comment">// 这是一个标示符，用来快速计算任务应该呆的格子。</span></span><br><span class="line">       <span class="comment">// 我们知道，给定一个deadline的定时任务，其应该呆的格子=deadline%wheel.length.但是%操作是个相对耗时的操作，所以使用一种变通的位运算代替：</span></span><br><span class="line">       <span class="comment">// 因为一圈的长度为2的n次方，mask = 2^n-1后低位将全部是1，然后deadline&amp;mast == deadline%wheel.length</span></span><br><span class="line">       <span class="comment">// java中的HashMap也是使用这种处理方法</span></span><br><span class="line">       mask = wheel.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 转换成纳秒处理</span></span><br><span class="line">       <span class="keyword">long</span> duration = unit.toNanos(tickDuration);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 校验是否存在溢出。即指针转动的时间间隔不能太长而导致tickDuration*wheel.length&gt;Long.MAX_VALUE</span></span><br><span class="line">       <span class="keyword">if</span> (duration &gt;= Long.MAX_VALUE / wheel.length) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                   <span class="string">"tickDuration: %d (expected: 0 &lt; tickDuration in nanos &lt; %d"</span>,</span><br><span class="line">                   tickDuration, Long.MAX_VALUE / wheel.length));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (duration &lt; MILLISECOND_NANOS) &#123;</span><br><span class="line">           <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">               logger.warn(<span class="string">"Configured tickDuration %d smaller then %d, using 1ms."</span>,</span><br><span class="line">                           tickDuration, MILLISECOND_NANOS);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">this</span>.tickDuration = MILLISECOND_NANOS;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.tickDuration = duration;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建worker线程</span></span><br><span class="line">       workerThread = threadFactory.newThread(worker);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 这里默认是启动内存泄露检测：当HashedWheelTimer实例超过当前cpu可用核数*4的时候，将发出警告</span></span><br><span class="line">       leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.maxPendingTimeouts = maxPendingTimeouts;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (INSTANCE_COUNTER.incrementAndGet() &gt; INSTANCE_COUNT_LIMIT &amp;&amp;</span><br><span class="line">           WARNED_TOO_MANY_INSTANCES.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">           <span class="comment">//发起警告</span></span><br><span class="line">           reportTooManyInstances();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里要注意,如果ticksPerWheel的默认值是512</li>
<li>HashedWheelTimer其实最终都是转换成纳秒处理的</li>
</ul>
</blockquote>
<h3 id="HashedWheelTimer的createWheel方法"><a href="#HashedWheelTimer的createWheel方法" class="headerlink" title="HashedWheelTimer的createWheel方法"></a>HashedWheelTimer的createWheel方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HashedWheelBucket[] createWheel(<span class="keyword">int</span> ticksPerWheel) &#123;</span><br><span class="line">       <span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                   <span class="string">"ticksPerWheel must be greater than 0: "</span> + ticksPerWheel);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (ticksPerWheel &gt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                   <span class="string">"ticksPerWheel may not be greater than 2^30: "</span> + ticksPerWheel);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 初始化ticksPerWheel的值为不小于ticksPerWheel的最小2的n次方</span></span><br><span class="line">       ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);</span><br><span class="line">       <span class="comment">// 初始化wheel数组</span></span><br><span class="line">       HashedWheelBucket[] wheel = <span class="keyword">new</span> HashedWheelBucket[ticksPerWheel];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wheel.length; i ++) &#123;</span><br><span class="line">           wheel[i] = <span class="keyword">new</span> HashedWheelBucket();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> wheel;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里要注意,创建时间轮数组的时候,最大长度不能超过2的30次方</li>
</ul>
</blockquote>
<h3 id="HashedWheelTimer的normalizeTicksPerWheel方法"><a href="#HashedWheelTimer的normalizeTicksPerWheel方法" class="headerlink" title="HashedWheelTimer的normalizeTicksPerWheel方法"></a>HashedWheelTimer的normalizeTicksPerWheel方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化ticksPerWheel的值为不小于ticksPerWheel的最小2的n次方</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">normalizeTicksPerWheel</span><span class="params">(<span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> normalizedTicksPerWheel = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (normalizedTicksPerWheel &lt; ticksPerWheel) &#123;</span><br><span class="line">           normalizedTicksPerWheel &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> normalizedTicksPerWheel;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里通过位运算来初始化每个轮盘的刻度</li>
<li>但这里有个问题,如果轮盘大小指定过大,这里的循环次数也会更多,性能会存在问题,此处可以进行优化[jdk1.8 hashmap的hash算法,后面深入了解下]</li>
</ul>
</blockquote>
<h3 id="HashedWheelTimer的start方法-时间轮启动的方法"><a href="#HashedWheelTimer的start方法-时间轮启动的方法" class="headerlink" title="HashedWheelTimer的start方法(时间轮启动的方法)"></a>HashedWheelTimer的start方法(时间轮启动的方法)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动时间轮。这个方法其实不需要显示的主动调用，因为在添加定时任务（newTimeout()方法）的时候会自动调用此方法。</span></span><br><span class="line">   <span class="comment">// 这个是合理的设计，因为如果时间轮里根本没有定时任务，启动时间轮也是空耗资源</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 判断当前时间轮的状态，如果是初始化，则启动worker线程，启动整个时间轮；如果已经启动则略过；如果是已经停止，则报错</span></span><br><span class="line">       <span class="comment">// 这里是一个Lock Free的设计。因为可能有多个线程调用启动方法，这里使用AtomicIntegerFieldUpdater原子的更新时间轮的状态</span></span><br><span class="line">       <span class="keyword">switch</span> (WORKER_STATE_UPDATER.get(<span class="keyword">this</span>)) &#123;</span><br><span class="line">       	 <span class="comment">//如果时间轮还没有启动,则更改状态并启动</span></span><br><span class="line">           <span class="keyword">case</span> WORKER_STATE_INIT:</span><br><span class="line">               <span class="keyword">if</span> (WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_INIT, WORKER_STATE_STARTED)) &#123;</span><br><span class="line">                   workerThread.start();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">//如果当前时间轮已经启动,则跳出该逻辑</span></span><br><span class="line">           <span class="keyword">case</span> WORKER_STATE_STARTED:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">//如果是关闭状态,抛出无法启动异常</span></span><br><span class="line">           <span class="keyword">case</span> WORKER_STATE_SHUTDOWN:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"cannot be started once stopped"</span>);</span><br><span class="line">           <span class="comment">//如果工作状态未指定,则表示该程序异常,直接error</span></span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Invalid WorkerState"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 等待worker线程初始化时间轮的启动时间</span></span><br><span class="line">       <span class="keyword">while</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               startTimeInitialized.await();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">               <span class="comment">// Ignore - it will be ready very soon.</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashedWheelTimer的stop方法-时间轮停止的方法"><a href="#HashedWheelTimer的stop方法-时间轮停止的方法" class="headerlink" title="HashedWheelTimer的stop方法(时间轮停止的方法)"></a>HashedWheelTimer的stop方法(时间轮停止的方法)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Timeout&gt; <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// worker线程不能停止时间轮，也就是加入的定时任务，不能调用这个方法。</span></span><br><span class="line">        <span class="comment">// 不然会有恶意的定时任务调用这个方法而造成大量定时任务失效</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() == workerThread) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    HashedWheelTimer.class.getSimpleName() +</span><br><span class="line">                            <span class="string">".stop() cannot be called from "</span> +</span><br><span class="line">                            TimerTask.class.getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试CAS替换当前状态为“停止：2”。如果失败，则当前时间轮的状态只能是“初始化：0”或者“停止：2”。直接将当前状态设置为“停止：2“</span></span><br><span class="line">        <span class="keyword">if</span> (!WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) &#123;</span><br><span class="line">            <span class="comment">// workerState can be 0 or 2 at this moment - let it always be 2.</span></span><br><span class="line">            <span class="keyword">if</span> (WORKER_STATE_UPDATER.getAndSet(<span class="keyword">this</span>, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">                INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line">                <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> closed = leak.close(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">assert</span> closed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//如果工作线程存活</span></span><br><span class="line">            <span class="keyword">while</span> (workerThread.isAlive()) &#123;</span><br><span class="line">                <span class="comment">//中断工作线程</span></span><br><span class="line">                <span class="comment">//interrupt()不能中断在运行中的线程，它只能改变中断状态而已。</span></span><br><span class="line">                workerThread.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//工作线程加入本地线程</span></span><br><span class="line">                    workerThread.join(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果发现线程已经被打上中断标识</span></span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                <span class="comment">//改变当前线程状态</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> closed = leak.close(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">assert</span> closed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> worker.unprocessedTimeouts();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashedWheelTimer的newTimeout方法"><a href="#HashedWheelTimer的newTimeout方法" class="headerlink" title="HashedWheelTimer的newTimeout方法"></a>HashedWheelTimer的newTimeout方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Timeout <span class="title">newTimeout</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"unit"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> pendingTimeoutsCount = pendingTimeouts.incrementAndGet();</span><br><span class="line">        <span class="comment">//待处理超时数 pendingTimeoutsCount 大于或等于允许的最大挂起</span></span><br><span class="line">        <span class="keyword">if</span> (maxPendingTimeouts &gt; <span class="number">0</span> &amp;&amp; pendingTimeoutsCount &gt; maxPendingTimeouts) &#123;</span><br><span class="line">            pendingTimeouts.decrementAndGet();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Number of pending timeouts ("</span></span><br><span class="line">                + pendingTimeoutsCount + <span class="string">") is greater than or equal to maximum allowed pending "</span></span><br><span class="line">                + <span class="string">"timeouts ("</span> + maxPendingTimeouts + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果时间轮没有启动，则启动</span></span><br><span class="line">        start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将超时添加到超时队列，该队列将在下一个时钟处理。</span></span><br><span class="line">        <span class="comment">//在处理过程中，所有排队的HashedWheelTimeouts都将添加到正确的HashedWheelBucket中。</span></span><br><span class="line">        <span class="keyword">long</span> deadline = System.nanoTime() + unit.toNanos(delay) - startTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止溢出。</span></span><br><span class="line">        <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; deadline &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            deadline = Long.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里定时任务不是直接加到对应的格子中，而是先加入到一个队列里，然后等到下一个tick的时候，会从队列里取出最多100000个任务加入到指定的格子中</span></span><br><span class="line">        HashedWheelTimeout timeout = <span class="keyword">new</span> HashedWheelTimeout(<span class="keyword">this</span>, task, deadline);</span><br><span class="line">        timeouts.add(timeout);</span><br><span class="line">        <span class="keyword">return</span> timeout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h3><blockquote>
<p>Worker是时间轮的核心线程类。tick的转动，过期任务的处理都是在这个线程中处理的。我们可以看到Worker实现Runnable接口,也就意味着我们的时间轮中是由worker来创建线程并执行任务</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Timeout&gt; unprocessedTimeouts = <span class="keyword">new</span> HashSet&lt;Timeout&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> tick;</span><br><span class="line">        <span class="comment">//... 省略方法</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Worker类中的run方法"><a href="#Worker类中的run方法" class="headerlink" title="Worker类中的run方法"></a>Worker类中的run方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 初始化startTime.只有所有任务的的deadline都是想对于这个时间点</span></span><br><span class="line">           startTime = System.nanoTime();</span><br><span class="line">           <span class="keyword">if</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// 由于System.nanoTime()可能返回0，甚至负数。并且0是一个标示符，用来判断startTime是否被初始化，所以当startTime=0的时候，重新赋值为1</span></span><br><span class="line">               startTime = <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 唤醒阻塞在start()的线程</span></span><br><span class="line">           startTimeInitialized.countDown();</span><br><span class="line">           <span class="comment">// 只要时间轮的状态为WORKER_STATE_STARTED，就循环的“转动”tick，循环判断响应格子中的到期任务</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               <span class="comment">// waitForNextTick方法主要是计算下次tick的时间, 然后sleep到下次tick</span></span><br><span class="line">               <span class="comment">// 返回值就是System.nanoTime() - startTime, 也就是Timer启动后到这次tick, 所过去的时间</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">long</span> deadline = waitForNextTick();</span><br><span class="line">               <span class="keyword">if</span> (deadline &gt; <span class="number">0</span>) &#123;   <span class="comment">// 可能溢出或者被中断的时候会返回负数, 所以小于等于0不管</span></span><br><span class="line">                   <span class="comment">// 获取tick对应的格子索引</span></span><br><span class="line">                   <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (tick &amp; mask);</span><br><span class="line">                   <span class="comment">// 移除被取消的任务</span></span><br><span class="line">                   processCancelledTasks();</span><br><span class="line">                   HashedWheelBucket bucket =</span><br><span class="line">                           wheel[idx];</span><br><span class="line">                   <span class="comment">// 从任务队列中取出任务加入到对应的格子中</span></span><br><span class="line">                   transferTimeoutsToBuckets();</span><br><span class="line">                   System.out.println(<span class="string">"bucket"</span>+bucket+<span class="string">",idx"</span>+idx);</span><br><span class="line">                   <span class="comment">// 过期执行格子中的任务</span></span><br><span class="line">                   bucket.expireTimeouts(deadline);</span><br><span class="line">                   tick++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_STARTED);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 这里应该是时间轮停止了，清除所有格子中的任务，并加入到未处理任务列表，以供stop()方法返回</span></span><br><span class="line">           <span class="keyword">for</span> (HashedWheelBucket bucket: wheel) &#123;</span><br><span class="line">               bucket.clearTimeouts(unprocessedTimeouts);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 将还没有加入到格子中的待处理定时任务队列中的任务取出，如果是未取消的任务，则加入到未处理任务队列中，以供stop()方法返回</span></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line">               <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (!timeout.isCancelled()) &#123;</span><br><span class="line">                   unprocessedTimeouts.add(timeout);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 处理取消的任务</span></span><br><span class="line">           processCancelledTasks();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Worker类中的transferTimeoutsToBuckets方法"><a href="#Worker类中的transferTimeoutsToBuckets方法" class="headerlink" title="Worker类中的transferTimeoutsToBuckets方法"></a>Worker类中的transferTimeoutsToBuckets方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将newTimeout()方法中加入到待处理定时任务队列中的任务加入到指定的格子中</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferTimeoutsToBuckets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 每次tick只处理10w个任务，以免阻塞worker线程</span></span><br><span class="line">          <span class="comment">// adds new timeouts in a loop.</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">              HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line">              <span class="comment">//System.out.println("当前times.size"+timeouts.size());</span></span><br><span class="line">              <span class="comment">// 如果没有任务了，直接跳出循环</span></span><br><span class="line">              <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// all processed</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 还没有放入到格子中就取消了，直接略过</span></span><br><span class="line">              <span class="keyword">if</span> (timeout.state() == HashedWheelTimeout.ST_CANCELLED) &#123;</span><br><span class="line">                  <span class="comment">// Was cancelled in the meantime.</span></span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 计算任务需要经过多少个tick</span></span><br><span class="line">              <span class="keyword">long</span> calculated = timeout.deadline / tickDuration;</span><br><span class="line">              <span class="comment">// 计算任务的轮数</span></span><br><span class="line">              timeout.remainingRounds = (calculated - tick) / wheel.length;</span><br><span class="line"></span><br><span class="line">              <span class="comment">//如果任务在timeouts队列里面放久了, 以至于已经过了执行时间, 这个时候就使用当前tick, 也就是放到当前bucket, 此方法调用完后就会被执行.</span></span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">long</span> ticks = Math.max(calculated, tick); <span class="comment">// Ensure we don't schedule for past.</span></span><br><span class="line">              System.out.println(<span class="string">"tick:"</span>+ticks);</span><br><span class="line">              <span class="keyword">int</span> stopIndex = (<span class="keyword">int</span>) (ticks &amp; mask);</span><br><span class="line">              <span class="comment">// 将任务加入到响应的格子中</span></span><br><span class="line">              HashedWheelBucket bucket = wheel[stopIndex];</span><br><span class="line">              bucket.addTimeout(timeout);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;b</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/16/2019-03-16-Dubbo 服务引用/">Dubbo 服务引用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DUBBO/">DUBBO</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/DUBBO/">DUBBO</a></span><div class="content"><h1 id="Dubbo-服务引用"><a href="#Dubbo-服务引用" class="headerlink" title="Dubbo 服务引用"></a>Dubbo 服务引用</h1><h2 id="服务引用"><a href="#服务引用" class="headerlink" title="服务引用"></a>服务引用</h2><blockquote>
<ul>
<li>大家都知道Dubbo是由consumer,provider,registry这三大部分组成<br><img src="http://dubbo.apache.org/img/architecture.png" alt=""></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>那么consumer是如何发现provider并调用的呢,就是通过服务引用来实现的,也就是通过发现服务,然后进行调用</li>
</ul>
</blockquote>
<h2 id="服务引用的流程"><a href="#服务引用的流程" class="headerlink" title="服务引用的流程"></a>服务引用的流程</h2><blockquote>
<p><img src="/img/dubbo服务引用.jpg" alt=""></p>
</blockquote>
<blockquote>
<ul>
<li>dubbo服务引用的流程大概如上图,不难发现其流程跟dubbo服务暴露互逆,(关于Dubbo服务暴露<a href="http://blog.leishunyu.com/2019/01/25/2019-01-25-Dubbo%20%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2/">Dubbo服务暴露</a>)但最终也是通过invoker来完成我们服务引用</li>
<li>dubbo服务引用最终通过ProxyFactory将Invoker转化为调用的Service</li>
<li>dubbo服务引用过程与dubbo服务暴露相似,都是通过SPI,适配相应的协议,并将服务注册到注册中心,并最终完成服务引用</li>
</ul>
</blockquote>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略一部分代码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取服务接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">//此处省略 配置校验代码</span></span><br><span class="line">        Boolean b = isInit();</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span> &amp;&amp; getConsumer() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            b = getConsumer().isInit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; b) &#123;</span><br><span class="line">        	<span class="comment">//发现服务</span></span><br><span class="line">            getObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>首先我们来看一下ReferenceBean, ReferenceBean实现了InitializingBean, ApplicationContextAware, ApplicationListener这里同服务暴露一样,通过spring在初始化的时候进行服务引用</li>
</ul>
</blockquote>
<h3 id="服务引用-1"><a href="#服务引用-1" class="headerlink" title="服务引用"></a>服务引用</h3><blockquote>
<ul>
<li>我们看到这里都调用了getObject()方法,其实是调用了ReferenceConfig中的get()方法,接下来我们一起看下ReferenceConfig中的get()方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//配置校验</span></span><br><span class="line">       checkAndUpdateSubConfigs();</span><br><span class="line">	<span class="comment">//如果该服务已被销毁,则抛出异常</span></span><br><span class="line">       <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The invoker of ReferenceConfig("</span> + url + <span class="string">") has already destroyed!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果服务为空,则进行初始化,否则直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">           init();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ref;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里看到ReferenceConfig.get方法上加了一个锁,用来保证不会重复发现服务,而该方法的核心在于init()方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       initialized = <span class="keyword">true</span>;</span><br><span class="line">       checkStubAndLocal(interfaceClass);</span><br><span class="line">       <span class="comment">//校验mock</span></span><br><span class="line">       checkMock(interfaceClass);</span><br><span class="line">       Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">       </span><br><span class="line">	<span class="comment">//省略对参数解析设置 ...</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建代理对象</span></span><br><span class="line">       ref = createProxy(map);</span><br><span class="line"></span><br><span class="line">       ApplicationModel.initConsumerModel(getUniqueServiceName(), buildConsumerModel(attributes));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里通过对参数的解析来创建服务代理, createProxy()方法是整个服务引用初始化的关键</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> T <span class="title">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">     URL tmpUrl = <span class="keyword">new</span> URL(<span class="string">"temp"</span>, <span class="string">"localhost"</span>, <span class="number">0</span>, map);</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> isJvmRefer;</span><br><span class="line">     <span class="keyword">if</span> (isInjvm() == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果指定了url，则不要进行本地引用</span></span><br><span class="line">             isJvmRefer = <span class="keyword">false</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 默认情况下，引用本地服务（如果有）</span></span><br><span class="line">             isJvmRefer = InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         isJvmRefer = isInjvm();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (isJvmRefer) &#123;</span><br><span class="line">         URL url = <span class="keyword">new</span> URL(Constants.LOCAL_PROTOCOL, Constants.LOCALHOST_VALUE, <span class="number">0</span>, interfaceClass.getName()).addParameters(map);</span><br><span class="line">         invoker = refprotocol.refer(interfaceClass, url);</span><br><span class="line">         <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">             logger.info(<span class="string">"Using injvm service "</span> + interfaceClass.getName());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; <span class="comment">// 用户指定的URL，可以是对等地址，也可以是注册中心的地址.</span></span><br><span class="line">             String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">             <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">                     URL url = URL.valueOf(u);</span><br><span class="line">                     <span class="keyword">if</span> (StringUtils.isEmpty(url.getPath())) &#123;</span><br><span class="line">                         url = url.setPath(interfaceName);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                         urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// x来自注册中心配置的URL</span></span><br><span class="line">             checkRegistry();</span><br><span class="line">             List&lt;URL&gt; us = loadRegistries(<span class="keyword">false</span>);</span><br><span class="line">             <span class="keyword">if</span> (CollectionUtils.isNotEmpty(us)) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                     URL monitorUrl = loadMonitor(u);</span><br><span class="line">                     <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">                     &#125;</span><br><span class="line">                     urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (urls.isEmpty()) &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such any registry to reference "</span> + interfaceName + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" use dubbo version "</span> + Version.getVersion() + <span class="string">", please config &lt;dubbo:registry address=\"...\" /&gt; to your spring config."</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">//这里的refprotocol.refer即通过registryProtocol来进行发现</span></span><br><span class="line">         <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">             invoker = refprotocol.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">             URL registryURL = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                 invokers.add(refprotocol.refer(interfaceClass, url));</span><br><span class="line">                 <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                     registryURL = url; <span class="comment">// 使用最后一个注册表网址</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">// 注册表网址可用</span></span><br><span class="line">                 <span class="comment">// 仅在寄存器的群集可用时才使用RegistryAwareCluster</span></span><br><span class="line">                 URL u = registryURL.addParameter(Constants.CLUSTER_KEY, RegistryAwareCluster.NAME);</span><br><span class="line">                 <span class="comment">//调用者包装关系将是：RegistryAwareClusterInvoker（StaticDirectory） - &gt; FailoverClusterInvoker（RegistryDirectory，将执行路由） - &gt; Invoker                    invoker = cluster.join(new StaticDirectory(u, invokers));</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不是注册表网址，必须直接调用。</span></span><br><span class="line">             	<span class="comment">//这里要注意 cluster 最终都会被包装成 MockClusterWrapper(SPI的依赖注入) </span></span><br><span class="line">                 invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Boolean c = check;</span><br><span class="line">     <span class="keyword">if</span> (c == <span class="keyword">null</span> &amp;&amp; consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">         c = consumer.isCheck();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">         c = <span class="keyword">true</span>; <span class="comment">// default true</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (c &amp;&amp; !invoker.isAvailable()) &#123;</span><br><span class="line">         <span class="comment">// 如果提供者暂时不可用，则允许消费者稍后重试</span></span><br><span class="line">         initialized = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to check the status of the service "</span> + interfaceName + <span class="string">". No provider available for the service "</span> + (group == <span class="keyword">null</span> ? <span class="string">""</span> : group + <span class="string">"/"</span>) + interfaceName + (version == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">":"</span> + version) + <span class="string">" from the url "</span> + invoker.getUrl() + <span class="string">" to the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" use dubbo version "</span> + Version.getVersion());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">         logger.info(<span class="string">"Refer dubbo service "</span> + interfaceClass.getName() + <span class="string">" from url "</span> + invoker.getUrl());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@since</span> 2.7.0</span></span><br><span class="line"><span class="comment">      * ServiceData Store</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     MetadataReportService metadataReportService = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> ((metadataReportService = getMetadataReportService()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         URL consumerURL = <span class="keyword">new</span> URL(Constants.CONSUMER_PROTOCOL, map.remove(Constants.REGISTER_IP_KEY), <span class="number">0</span>, map.get(Constants.INTERFACE_KEY), map);</span><br><span class="line">         metadataReportService.publishConsumer(consumerURL);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// create service proxy</span></span><br><span class="line">     <span class="keyword">return</span> (T) proxyFactory.getProxy(invoker);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里可以看到dubbo在服务引用中也可以使用本地服务的发现,但是可看到这一块已经被标记为过时,我的理解是dubbo作为一个RPC框架,本地服务还通过dubbo去调用,肯定与dubbo本身的意义不相匹配,所以便不推荐使用</li>
<li>这块代码我们可以发现同服务暴露一样,会将consumer注册到所有配置的注册中心上去,而refprotocol.refer则是服务引用的核心代码</li>
<li>cluster对invoker进行了一层包装,以便应对后续服务调用中出现的异常情况进行处理</li>
<li>最后我们的invoker将通过代理工厂转换为可以调用的代理服务</li>
</ul>
</blockquote>
<h3 id="RegistryProtocal中的refer"><a href="#RegistryProtocal中的refer" class="headerlink" title="RegistryProtocal中的refer"></a>RegistryProtocal中的refer</h3><figure class="highlight java"><figcaption><span>RegistryProtocal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       url = url.setProtocol(url.getParameter(REGISTRY_KEY, DEFAULT_REGISTRY)).removeParameter(REGISTRY_KEY);</span><br><span class="line">       <span class="comment">//获取注册中心</span></span><br><span class="line">       Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">       <span class="comment">//如果是注册中心的服务,直接返回注册中心类型的invoker</span></span><br><span class="line">       <span class="keyword">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class="line">           <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// group="a,b" or group="*"</span></span><br><span class="line">       Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">       String group = qs.get(Constants.GROUP_KEY);</span><br><span class="line">       <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="number">1</span> || <span class="string">"*"</span>.equals(group)) &#123;</span><br><span class="line">               <span class="keyword">return</span> doRefer(getMergeableCluster(), registry, type, url);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//发现服务</span></span><br><span class="line">       <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">//创建并设置注册目录对象</span></span><br><span class="line">       RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">       directory.setRegistry(registry);</span><br><span class="line">       directory.setProtocol(protocol);</span><br><span class="line">       <span class="comment">// all attributes of REFER_KEY</span></span><br><span class="line">       Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">       URL subscribeUrl = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">       <span class="keyword">if</span> (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">           directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">           <span class="comment">//注册服务</span></span><br><span class="line">           registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">       &#125;</span><br><span class="line">       directory.buildRouterChain(subscribeUrl);</span><br><span class="line">       <span class="comment">//订阅服务</span></span><br><span class="line">       directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,</span><br><span class="line">               PROVIDERS_CATEGORY + <span class="string">","</span> + CONFIGURATORS_CATEGORY + <span class="string">","</span> + ROUTERS_CATEGORY));</span><br><span class="line">	<span class="comment">//装饰Invoker</span></span><br><span class="line">       Invoker invoker = cluster.join(directory);</span><br><span class="line">       ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br><span class="line">       <span class="keyword">return</span> invoker;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>在RegistryProtocal中,我们看到了cluster.join(directory),在ReferenceConfig中也出现过,在ReferenceConfig中没有注册中心的时候将直接使用装饰invoker,以供我们接下来服务调用来做集群容错</li>
<li>服务引用在RegistryProtocal中的核心方法即为doRefer方法</li>
</ul>
</blockquote>
<h3 id="RegistryDirectory"><a href="#RegistryDirectory" class="headerlink" title="RegistryDirectory"></a>RegistryDirectory</h3><figure class="highlight java"><figcaption><span>RegistryDirectory</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将网址转换为调用者，如果网址已被引用，则不会重新引用。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> urls</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> invokers</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class="line">       Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">       &#125;</span><br><span class="line">       Set&lt;String&gt; keys = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       String queryProtocols = <span class="keyword">this</span>.queryMap.get(Constants.PROTOCOL_KEY);</span><br><span class="line">       <span class="keyword">for</span> (URL providerUrl : urls) &#123;</span><br><span class="line">           <span class="comment">// 如果在参考侧配置协议，则仅选择匹配协议</span></span><br><span class="line">           <span class="keyword">if</span> (queryProtocols != <span class="keyword">null</span> &amp;&amp; queryProtocols.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">boolean</span> accept = <span class="keyword">false</span>;</span><br><span class="line">               String[] acceptProtocols = queryProtocols.split(<span class="string">","</span>);</span><br><span class="line">               <span class="keyword">for</span> (String acceptProtocol : acceptProtocols) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (providerUrl.getProtocol().equals(acceptProtocol)) &#123;</span><br><span class="line">                       accept = <span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (!accept) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) &#123;</span><br><span class="line">               logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported protocol "</span> + providerUrl.getProtocol() +</span><br><span class="line">                       <span class="string">" in notified url: "</span> + providerUrl + <span class="string">" from registry "</span> + getUrl().getAddress() +</span><br><span class="line">                       <span class="string">" to consumer "</span> + NetUtils.getLocalHost() + <span class="string">", supported protocol: "</span> +</span><br><span class="line">                       ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           URL url = mergeUrl(providerUrl);</span><br><span class="line"></span><br><span class="line">           String key = url.toFullString(); <span class="comment">// 参数URL已排序</span></span><br><span class="line">           <span class="keyword">if</span> (keys.contains(key)) &#123; <span class="comment">//重复的网址</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           keys.add(key);</span><br><span class="line">           <span class="comment">// 缓存键是不与消费者方参数合并的URL，无论消费者如何组合参数，如果服务器URL更改，则再次引用</span></span><br><span class="line">           Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// 本地发现</span></span><br><span class="line">           Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="keyword">null</span> ? <span class="keyword">null</span> : localUrlInvokerMap.get(key);</span><br><span class="line">           <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123; <span class="comment">// 不在缓存中，请再次发现</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">boolean</span> enabled = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="keyword">if</span> (url.hasParameter(Constants.DISABLED_KEY)) &#123;</span><br><span class="line">                       enabled = !url.getParameter(Constants.DISABLED_KEY, <span class="keyword">false</span>);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       enabled = url.getParameter(Constants.ENABLED_KEY, <span class="keyword">true</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                       invoker = <span class="keyword">new</span> InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                   logger.error(<span class="string">"Failed to refer invoker for interface:"</span> + serviceType + <span class="string">",url:("</span> + url + <span class="string">")"</span> + t.getMessage(), t);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123; <span class="comment">// Put new invoker in cache</span></span><br><span class="line">                   newUrlInvokerMap.put(key, invoker);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               newUrlInvokerMap.put(key, invoker);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       keys.clear();</span><br><span class="line">       <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>那我们的服务最后是如何通相应协议打开consumer和provider的链接呢,关键代码就在RegistryDirectory的toInvokers方法,将url转换成具体的invoker,这个方法在订阅服务的时候会被触发,并且这里做了一层缓存,防止服务被多次引用</li>
</ul>
</blockquote>
<h3 id="DubboProtocal中的refer"><a href="#DubboProtocal中的refer" class="headerlink" title="DubboProtocal中的refer"></a>DubboProtocal中的refer</h3><figure class="highlight java"><figcaption><span>DubboProtocol</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// create rpc invoker.</span></span><br><span class="line">       DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">       invokers.add(invoker);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> invoker;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里我们以Dubbo协议为例,看到DubboProtocal中的refer很简单,就是创建一个netty客户端,与provider进行连接返回一个Invoker即完成了一次服务的引用</li>
<li>最后通过ProxyFactory的字节码结束,生成代理的可供调用的服务,到这里dubbo服务引用的流程就结束了,可以看出服务引用与服务暴露的过程中有很多类似的地方,其中还有很多细节没有展开,这也将是后续学习的重点</li>
</ul>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/25/2019-01-25-Dubbo 服务暴露/">Dubbo 服务暴露</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DUBBO/">DUBBO</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/DUBBO/">DUBBO</a></span><div class="content"><h1 id="Dubbo-服务暴露"><a href="#Dubbo-服务暴露" class="headerlink" title="Dubbo 服务暴露"></a>Dubbo 服务暴露</h1><h2 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h2><blockquote>
<ul>
<li>大家都知道Dubbo是由consumer,provider,registry这三大部分组成<br><img src="http://dubbo.apache.org/img/architecture.png" alt=""></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>那么provider的如何将服务提供给consumer调用呢,就是通过服务暴露来实现的,也就是把我们原来单机架构中的接口,对外部暴露</li>
</ul>
</blockquote>
<h2 id="服务暴露的流程"><a href="#服务暴露的流程" class="headerlink" title="服务暴露的流程"></a>服务暴露的流程</h2><blockquote>
<p><img src="/img/dubbo服务暴露.png" alt=""></p>
</blockquote>
<blockquote>
<ul>
<li>dubbo服务暴露的流程大概如上图,在dubbo中,所有的服务都会被包装成一个invoker,这一点也将贯穿今后整个学习</li>
<li>dubbo服务暴露可以理解为两部分:本地暴露,远程暴露</li>
<li>本地暴露的接口通常用于我们直接invoke dubbo的接口,以及有些时候我们的服务既是provider又是consumer,避免远程调用造成的资源浪费</li>
<li>远程暴露则是将服务信息注册到registry,并且将服务通过网络提供给其他应用调用</li>
</ul>
</blockquote>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">213195494150089726L</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *此处省略其他代码</span></span><br><span class="line"><span class="comment">	 **/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"The service ready on spring started. service: "</span> + getInterface());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//服务暴露</span></span><br><span class="line">            export();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"deprecation"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	 <span class="comment">//此处省略....</span></span><br><span class="line">        <span class="keyword">if</span> (!supportedApplicationListener) &#123;</span><br><span class="line">            <span class="comment">//服务暴露</span></span><br><span class="line">            export();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>首先我们来看一下ServiceBean,ServiceBean实现了InitializingBean, ApplicationContextAware, ApplicationListener有没有觉得很熟悉,实现这几个类就能在spring初始化的时候do something</li>
</ul>
</blockquote>
<h3 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h3><blockquote>
<ul>
<li>我们看到这里都调用了export()方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (export == <span class="keyword">null</span>) &#123;</span><br><span class="line">               export = provider.getExport();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (delay == <span class="keyword">null</span>) &#123;</span><br><span class="line">               delay = provider.getDelay();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (export != <span class="keyword">null</span> &amp;&amp; !export) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (delay != <span class="keyword">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           delayExportExecutor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   doExport();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           doExport();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里看到ServiceConfig.export方法上加了一个锁,用来保证不会重复暴露服务,抛开上面的逻辑判断,在第一次初始化的时候,是直接走到了doExport()方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//省略判断代码</span></span><br><span class="line">	doExportUrls();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//加载注册中心的配置</span></span><br><span class="line">       List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">//把使用的协议注册到注册中心 </span></span><br><span class="line">       <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">           doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这里dubbo支持多协议,可以看到通过for循环可以把配置的多种协议都导出,进行暴露</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">	 <span class="comment">//省略判断代码</span></span><br><span class="line">    <span class="comment">// 导出服务</span></span><br><span class="line">    String contextPath = protocolConfig.getContextpath();</span><br><span class="line">    <span class="keyword">if</span> ((contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span>) &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        contextPath = provider.getContextpath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String host = <span class="keyword">this</span>.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">    Integer port = <span class="keyword">this</span>.findConfigedPorts(protocolConfig, name, map);</span><br><span class="line">    URL url = <span class="keyword">new</span> URL(name, host, port, (contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span> ? <span class="string">""</span> : contextPath + <span class="string">"/"</span>) + path, map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">            .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String scope = url.getParameter(Constants.SCOPE_KEY);</span><br><span class="line">    <span class="comment">// 没有配置时不导出</span></span><br><span class="line">    <span class="keyword">if</span> (!Constants.SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">        <span class="comment">// 导出本地服务</span></span><br><span class="line">        <span class="keyword">if</span> (!Constants.SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            exportLocal(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 导出远程服务</span></span><br><span class="line">        <span class="keyword">if</span> (!Constants.SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to url "</span> + url);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (registryURLs != <span class="keyword">null</span> &amp;&amp; !registryURLs.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//将服务都注册到当前已有的注册中心上去</span></span><br><span class="line">                <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                    url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));</span><br><span class="line">                    <span class="comment">//判断是否有监控中心</span></span><br><span class="line">                    URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line">                    <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Register dubbo service "</span> + interfaceClass.getName() + <span class="string">" url "</span> + url + <span class="string">" to registry "</span> + registryURL);</span><br><span class="line">                    &#125;</span><br><span class="line">			<span class="comment">//对于providers，这用于启用自定义代理以生成invoker</span></span><br><span class="line">                    String proxy = url.getParameter(Constants.PROXY_KEY);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                        registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line">                    <span class="comment">//包装调用者和所有元数据的Invoker包装器</span></span><br><span class="line">                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">//没有注册中心直接暴露</span></span><br><span class="line">                Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                <span class="comment">//包装调用者和所有元数据的Invoker包装器</span></span><br><span class="line">                DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line">                Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                exporters.add(exporter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.urls.add(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露本地服务</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportLocal</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">        <span class="comment">//手动暴露一个本地服务</span></span><br><span class="line">        URL local = URL.valueOf(url.toFullString())</span><br><span class="line">                .setProtocol(Constants.LOCAL_PROTOCOL)</span><br><span class="line">                .setHost(LOCALHOST)</span><br><span class="line">                .setPort(<span class="number">0</span>);</span><br><span class="line">        Exporter&lt;?&gt; exporter = protocol.export(</span><br><span class="line">                proxyFactory.getInvoker(ref, (Class) interfaceClass, local));</span><br><span class="line">        exporters.add(exporter);</span><br><span class="line">        logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to local registry"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这你scope配置默认值是null,则本地服务和远程服务都导出,另外如果没有配置注册中心,将直接将接口暴露出去,我们可以根据自己所在的场景,选择都暴露还是指定暴露</li>
<li>由于dubbo也是支持多注册中心的,所以可以通过for循环,将多个服务都注册到当前已有的注册中心上去</li>
<li>在exportLocal方法这是将配置中解析好的url参数手动修改成本地协议进行服务暴露</li>
<li>ProxyFactory是通过SPI获取JavassistProxyFactory靠Javassist字节码技术动态的生成Invoker类,大家有兴趣的可以下去了解一下</li>
</ul>
</blockquote>
<h3 id="暴露的细节"><a href="#暴露的细节" class="headerlink" title="暴露的细节"></a>暴露的细节</h3><figure class="highlight java"><figcaption><span>ProtocolFilterWrapper</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolFilterWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line">    <span class="comment">//装饰者模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolFilterWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>在ServiceConfig中,通过SPI获取相应的Protocol,SPI中会对实现类进行装饰,每次执行protocol.exprot()方法的时候,其实都是执行的ProtocolFilterWrapper的protocol.exprot方法</li>
</ul>
</blockquote>
<figure class="highlight java"><figcaption><span>ProtocolFilterWrapper</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//如果是注册中心协议直接导出</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是则执行整个filter的责任链</span></span><br><span class="line">    <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//责任链模式,对filter进行逐个执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class="line">    Invoker&lt;T&gt; last = invoker;</span><br><span class="line">    List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br><span class="line">    <span class="keyword">if</span> (!filters.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> Filter filter = filters.get(i);</span><br><span class="line">            <span class="keyword">final</span> Invoker&lt;T&gt; next = last;</span><br><span class="line">            last = <span class="keyword">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> invoker.getInterface();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> invoker.getUrl();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> invoker.isAvailable();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">                    Result result = filter.invoke(next, invocation);</span><br><span class="line">                    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> AsyncRpcResult) &#123;</span><br><span class="line">                        AsyncRpcResult asyncResult = (AsyncRpcResult) result;</span><br><span class="line">                        asyncResult.thenApplyWithContext(r -&gt; filter.onResponse(r, invoker, invocation));</span><br><span class="line">                        <span class="keyword">return</span> asyncResult;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> filter.onResponse(result, invoker, invocation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    invoker.destroy();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> invoker.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>由上述代码我们可以看到,dubbo中运用装饰者模式和责任链模式,对我们提供的服务做了一次封装,最终转换成我们需要的invoker对外暴露</li>
<li>要注意到的是,当我们的协议是registry也就是注册协议的时候,是不需要进行构建责任链的</li>
</ul>
</blockquote>
<h3 id="本地暴露"><a href="#本地暴露" class="headerlink" title="本地暴露"></a>本地暴露</h3><figure class="highlight java"><figcaption><span>InjvmProtocol</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>如果是本地暴露,则通过SPI拿到InjvmProtocol,最终通过injvm协议导出InjvmExporter</li>
</ul>
</blockquote>
<h3 id="远程暴露"><a href="#远程暴露" class="headerlink" title="远程暴露"></a>远程暴露</h3><figure class="highlight java"><figcaption><span>DubboProtocol</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       URL url = invoker.getUrl();</span><br><span class="line">       <span class="comment">// 导出服务.</span></span><br><span class="line">       String key = serviceKey(url);</span><br><span class="line">       DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">       exporterMap.put(key, exporter);</span><br><span class="line">       <span class="comment">//导出根服务以进行调度事件</span></span><br><span class="line">       Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);</span><br><span class="line">       Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">       <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">           String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">           <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                   logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"consumer ["</span> + url.getParameter(Constants.INTERFACE_KEY) +</span><br><span class="line">                           <span class="string">"], has set stubproxy support event ,but no stub methods founded."</span>));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//打开服务</span></span><br><span class="line">       openServer(url);</span><br><span class="line">       optimizeSerialization(url);</span><br><span class="line">       <span class="keyword">return</span> exporter;</span><br><span class="line">   &#125;	</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//打开服务</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// find server.</span></span><br><span class="line">       String key = url.getAddress();</span><br><span class="line">       <span class="comment">//客户端可以导出仅供服务器调用的服务</span></span><br><span class="line">       <span class="keyword">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY, <span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">           ExchangeServer server = serverMap.get(key);</span><br><span class="line">           <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                   server = serverMap.get(key);</span><br><span class="line">                   <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">//如果服务不存在,创建服务</span></span><br><span class="line">                       serverMap.put(key, createServer(url));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 服务器支持重置，与override一起使用</span></span><br><span class="line">               server.reset(url);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>在dubbo协议中,我们看到在服务导出的时候会根据配置地址,打开netty服务,也就是通过这一步,开启了RPC端口,使consumer通过TCP协议进行服务调用</li>
</ul>
</blockquote>
<h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><figure class="highlight java"><figcaption><span>RegistryProtocol</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">       <span class="comment">// url在本地导出</span></span><br><span class="line">       URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line">       <span class="comment">// 订阅覆盖数据</span></span><br><span class="line">       <span class="comment">// 同样的服务由于订阅是带有服务名称的缓存密钥，因此会导致订阅信息覆盖。</span></span><br><span class="line">       <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);</span><br><span class="line">       <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">       overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">       providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class="line">       <span class="comment">//导出invoker</span></span><br><span class="line">       <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class="line">       <span class="comment">//将url注册到注册中心</span></span><br><span class="line">       <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">       <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line">       ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class="line">               registryUrl, registeredProviderUrl);</span><br><span class="line">       <span class="comment">//判断我们是否需要推迟发布</span></span><br><span class="line">       <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">if</span> (register) &#123;</span><br><span class="line">           register(registryUrl, registeredProviderUrl);</span><br><span class="line">           providerInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Deprecated! Subscribe to override rules in 2.6.x or before.</span></span><br><span class="line">       registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">       exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">       exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line">       <span class="comment">//确保每次导出时都返回一个新的导出器实例</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;&gt;(exporter);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//真正导出服务的地方</span></span><br><span class="line">	<span class="keyword">private</span> &lt;T&gt; <span class="function">ExporterChangeableWrapper&lt;T&gt; <span class="title">doLocalExport</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker, URL providerUrl)</span> </span>&#123;</span><br><span class="line">       String key = getCacheKey(originInvoker);</span><br><span class="line">       ExporterChangeableWrapper&lt;T&gt; exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">       <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (bounds) &#123;</span><br><span class="line">               exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">               <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">final</span> Invoker&lt;?&gt; invokerDelegete = <span class="keyword">new</span> InvokerDelegate&lt;T&gt;(originInvoker, providerUrl);</span><br><span class="line">                   <span class="comment">//以dubbo协议为例,这里才是真正调用DubboProtocol.exprot的地方</span></span><br><span class="line">                   exporter = <span class="keyword">new</span> ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegete), originInvoker);</span><br><span class="line">                   bounds.put(key, exporter);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> exporter;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>大家这里可以跟进源码,会发现,在ServiceConfig中通过proxyFactory生成的Invoker的url指向的协议其实是registry,所以在ServiceConfig中protocol.exprot调用的是RegistryProtocol的exprot方法</li>
<li>在RegistryProtocol中调用了真正的远程服务暴露的方法,即DubboProtocol(以dubbo协议为例),在远程服务暴露成功后,将服务信息注册到registry上去,由此完成了一个服务的导出</li>
<li>至此Dubbo服务暴露中的大致流程已经完成了,后面将会对Dubbo如何通过ProxyFactory生成Invoker,以及Registry是如何进行注册的进行更加深入的学习</li>
</ul>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/19/2019-01-19-锁优化/">JVM 锁优化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JVM/">JVM</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JVM/">JVM</a></span><div class="content"><h1 id="什么是锁优化"><a href="#什么是锁优化" class="headerlink" title="什么是锁优化"></a>什么是锁优化</h1><blockquote>
<ul>
<li>为了线程之间更高效的共享数据,以及解决竞争问题,在JDK1.5之后,对锁进行了大量的优化,由此衍生出(自适应)自旋锁/轻量级锁/偏向级锁/锁消除/锁粗化等技术</li>
</ul>
</blockquote>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><blockquote>
<ul>
<li>锁消除是指虚拟机即时编译器在运行时,对一些代码上的同步要求,检测到是不可能存在共享数据竞争的,这时就会对锁进行清除,这里就好比我们去火车站买票需要排队,为了保证秩序,一般都会有一些围挡限制值人,但是现在不是高峰期,发现根本不需要做一些围栏来限制秩序,这个时候车站安保人员就会把围栏撤掉,这里这个围挡就相当于我们的锁,会根据实际情况来进行判断</li>
<li>锁消除主要源于逃逸分析的数据支持,如果判断一段代码中,堆上的所有数据都不会逃逸出去被其他线程访问,那么可以把它当做栈上数据来对待,认为他是线程私有的,那么就不用加锁了</li>
<li>要注意的是,不仅仅是我们在开发中手动加的锁,在有些场景中,同步代码也是普遍存在的</li>
</ul>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String s1,String s2,String s3)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> s1 + s2 + s3 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>我们知道,由于String是一个不可变类,对字符串的操作是转换成新的String对象来进行的,在jdk1.5及以前的版本,这个字符串拼接会被javac编译成</li>
</ul>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//javac编译后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String s1,String s2,String s3)</span></span>&#123;</span><br><span class="line">	StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">	sb.append(s1);</span><br><span class="line">	sb.append(s2);</span><br><span class="line">	sb.append(s3);</span><br><span class="line">   <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//StringBuffer的append方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       toStringCache = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">super</span>.append(str);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>但是我们看到StringBuffer的append方法是一个同步方法,但是在该方法中,并不需要加锁,所以在jdk1.5以后的版本, StringBuffer会被优化成StringBuilder,而StringBuilder是不加锁的</li>
</ul>
</blockquote>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><blockquote>
<ul>
<li>一般我们在开发过程中,推荐将同步块的作用域限制的尽量小,最好是只在共享数据的实际操作的作用域加锁,这样使得需要同步的操作数量尽可能小,如果存在锁竞争,那等待的线程也能够尽快拿到锁</li>
<li>在大部分情况中上述原则是正确的,但是如果一些列连续都操作都是对同一个对象进行反复的加锁解锁操作,甚至在循环中出现这样的问题,那样既是没有线程的竞争,也会频繁的触发互斥同步的操作,对性能是有巨大损耗的</li>
<li>如何解决这类问题呢,那么就是锁粗化,顾名思义,就是将细粒度的锁变成粗粒度的锁,如果虚拟机探测到有这样一系列零零碎碎的操作都对同一个对象加锁,会把这个锁同步范围扩大到整个操作序列的外部,以上面的concat方法为例,把原来每个append方法上的锁变成对concat方法的锁</li>
</ul>
</blockquote>
<h2 id="自旋锁-自适应自旋锁"><a href="#自旋锁-自适应自旋锁" class="headerlink" title="自旋锁/自适应自旋锁"></a>自旋锁/自适应自旋锁</h2><blockquote>
<p><img src="/img/自旋锁.jpg" alt="自旋锁"></p>
</blockquote>
<blockquote>
<ul>
<li>提到自旋锁,我们先回到互斥同步本身,我们知道互斥同步有个很大的问题,就是阻塞实现,挂起线程和恢复线程都是内核态的操作,这些操作会给系统并发性能带来很大的压力,而且在很多场景中,共享数据的锁定只会持续很短的时间,而为了这段时间去恢复和挂起线程是非常不值得的,所以就有了自旋锁</li>
<li>自旋锁,前提是机器有一核以上的处理器(一核的机器现在已经很少了,可以忽略这个前提),能让两个以上的线程并行执行,这个时候我们可以让后面请求锁的线程稍微等一会,看看持有锁的线程能否快速的释放这个锁,为了让线程陷入等待,就出现了自旋(说白了就是循环),在JUC包中我们可以看到AQS中出现的下面代码,就是基于CAS实现的自旋锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">	doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>自旋锁虽然避免了线程切换带来的开销,但是在处理时间上却变得更长,如果锁占用的时间很短,那自旋等待的效果就很好,如果锁占用的时间长,那么自旋的线程只会白白浪费处理器的资源,而不会做其他有用的工作,反而会带来性能上的浪费,因此,在自旋到一定时间后还没有获得锁,就会将线程挂起,自旋的默认次数是10</li>
<li>自适应自旋锁,顾名思义就是自动适配的自旋锁,它的自旋时间不在固定,而是由上一次同一个锁上的自旋时间和锁的拥有者的状态来决定的,由此可见JVM更加智能了,对于经常获得锁的,自旋的时间会尽可能的长,而对于自旋经常获取不到锁的线程,就直接挂起线程,避免资源的浪费</li>
</ul>
</blockquote>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><blockquote>
<p><img src="/img/轻量级锁.jpg" alt="轻量级锁"></p>
</blockquote>
<blockquote>
<ul>
<li>轻量级锁也是jdk1.6之后引入的新型锁机制,轻量级是相对于使用操作系统的互斥量来实现的传统锁而言,因此传统的锁机制就被称为重量级锁,这里要强调一点的是,轻量级锁不是用来代替重量级锁的,它的本意是避免在没有锁竞争的情况下,使用重量级锁造成的资源浪费</li>
<li>说到轻量级锁,首先要了解对象头的内容<a href="http://blog.leishunyu.com/2019/01/11/2019-01-11-jvm%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/">对象在JVM中的储存</a>,对象在没有进入同步块的时候,如果此同步对象没有被锁定(锁标识为”01”的状态), jvm将在栈中建立一个LockRecord的空间,用于存储当前对象MarkWord的拷贝(Displaced MarkWord),如上图所示,然后虚拟机将使用CAS操作尝试对对象头的MarkWord更新为指向LockRecord的指针,如果更新成功,则对象拥有对该对象的锁,并且将锁标识转变成”00”</li>
<li>如果更新失败了,jvm会首先检查对象的MarkWord是否指向当前的栈,如果指向当前线程的栈,则说明已经获得锁,那就可以进入同步块去执行,如果没有指向,则说明当前线程的锁已经被其他线程抢占了,如果有两条以上的线程去争夺同一个锁,那么轻量级锁就会失效,膨胀为重量级锁,锁标识的状态值也会变为”10”, MarkWord指向的就是重量级锁(互斥量的指针),后面等待锁的线程也要进入阻塞状态</li>
<li>轻量级锁解锁也是通过CAS进行的,如果对象的MarkWord仍然指向着线程的锁记录,那就用CAS把对象当前的MarkWord替换回来,如果替换成功,说明整个同步过程就完成了,如果替换失败,说明其他线程尝试获取过锁,那么在释放锁的时候还要唤起其他被挂起的线程</li>
<li>轻量级锁提升性能的依据在于,对于大部分的锁,在整个同步周期内都是不存在竞争的,这只是一个经验数据,如果没有竞争,轻量级锁使用CAS操作避免了使用互斥线程的开销,但是如果存在竞争,那么除了互斥开销外,还有CAS的开销,在有竞争的情况下,轻量级锁会比传统的重量级锁更慢</li>
</ul>
</blockquote>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><blockquote>
<p><img src="/img/偏向锁.jpg" alt="偏向锁"></p>
<ul>
<li>偏向锁和轻量级锁类似,也是对于MarkWord的一系列操作,顾名思义,偏向锁,是指偏向某一个线程的锁,偏向锁会偏向第一个获取他的线程,如果在接下来的执行当中都没有其他线程获取,那么持有偏向锁的线程将永远不用在进行同步</li>
<li>当锁第一次被对象获取时,在将锁标识为”01”,即偏向锁模式,然后使用CAS操作把线程ID记录到MarkWord中,如果更新成功,持有偏向锁的线程,每次进入同步块时都不需要重新加锁</li>
<li>当有另一个线程尝试获得锁时,偏向模式宣告结束,根据锁对象目前是否处于被锁定的状态,决定撤销偏向,还是升级到轻量级锁</li>
<li>偏向锁可以提高带有同步但是无竞争的程序性能,同样是有利有弊,如果程序中大部分锁是要被多个不同线程访问,偏向锁肯定是有负担的</li>
</ul>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/11/2019-01-11-jvm对象在内存中的存储/">JVM 对象在内存中的存储</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JVM/">JVM</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JVM/">JVM</a></span><div class="content"><h1 id="对象在内存中的存储"><a href="#对象在内存中的存储" class="headerlink" title="对象在内存中的存储"></a>对象在内存中的存储</h1><blockquote>
<ul>
<li>如图1,可以看到一个对象在JVM内存中是如何存储的</li>
</ul>
</blockquote>
<p><img src="/img/对象头1.jpg" alt="图1"></p>
<h2 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h2><blockquote>
<ul>
<li>对象头主要包括MarkWord,class指针,如果是数组还有数组的长度</li>
<li>MarkWord:包括对象的hashcode,GC分代年龄,锁状态标识,线程持有的锁,偏向线程ID,如下图<br><img src="/img/jvm32.jpg" alt="32位jvm中MarkWord"><br><img src="/img/jvm64.jpg" alt="64位jvm中MarkWord"></li>
<li>如上图所示,我们可以发现对象年龄分代为4bit,最大值也就是1111-&gt;15,所以在GC回收的时候,年龄超过15的对象会被加入老年代<a href="http://blog.leishunyu.com/2019/01/10/2019-01-10-jvm%E6%96%B0%E7%94%9F%E4%BB%A3:%E8%80%81%E5%B9%B4%E4%BB%A3/">JVM新生代/老年代</a></li>
<li>上图锁相关的标识将在后面的锁优化进行展开</li>
</ul>
</blockquote>
<h2 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h2><blockquote>
<ul>
<li>对象真正存储的有效数据,各种字段内容</li>
</ul>
</blockquote>
<h2 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h2><blockquote>
<ul>
<li>不是必然存储,hotspot的自动内存管理要求对象大小必须是8字节的整数倍,而对象头正好是8字节的整数倍,所有实例数据部分如果没有对齐时,就需要通过对齐来自动填充</li>
</ul>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/10/2019-01-10-mysql innodb 表相关/">mysql innodb 表相关</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/数据库原理/">数据库原理</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MYSQL/">MYSQL</a></span><div class="content"><h1 id="innodb-表相关知识导图"><a href="#innodb-表相关知识导图" class="headerlink" title="innodb 表相关知识导图"></a>innodb 表相关知识导图</h1><p><img src="/img/表.jpg" alt=""></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/10/2019-01-10-jvm新生代:老年代/">JVM 新生代/老年代</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JVM/">JVM</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JVM/">JVM</a></span><div class="content"><h1 id="JVM-GC-流程图"><a href="#JVM-GC-流程图" class="headerlink" title="JVM GC 流程图"></a>JVM GC 流程图</h1><p><img src="/img/新生代-老年代.jpg" alt="图1"></p>
<h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><blockquote>
<ul>
<li>主要是用来存放新生对象,一般占据对的1/3,由于频繁的创建对象,所以新生代会频繁的触发MinorGC进行垃圾回收</li>
<li>新生代又分为Eden,SurvivorTo,SurvivorForm三个区</li>
<li>Eden区:JAVA新对象的出生地(如果新创建的对象占用内存很大,就直接分配到老年代),当Eden内存不够时,将触发一次MinorGC,对新生代进行一次回收,Eden占整个新生代的80%</li>
<li>SurvivorTo(SurvivorForm):保留了一次MinorGC的幸存者,占用新生代的10%</li>
<li>SurvivorForm(SurvivorTo):上一次MinorGC的幸存者,将和Eden一次参与这一次MinorGC扫描,占用新生代的10%</li>
<li>MinorGC的过程如果这次GC还幸存下来的对象,将复制到SurvivorTo中, SurvivorTo变成SurvivorForm,SurvivorForm变成SurvivorTo,并将对象年龄+1,这里就采用了标记-复制算法(由于新生代中都是朝生夕灭),如果发现SurvivorForm中的对象达到了老年标准,就把对象移动到老年代,一般年龄默认是15</li>
</ul>
</blockquote>
<h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><blockquote>
<ul>
<li>老年代主要存放的对象都比较稳定,一般存放的是应用程序中生命周期长的对象,当然也不排除有些朝生夕死的大对象,所以FullGC不会频繁的执行</li>
<li>一般进行FullGC之前都会触发一次MinorGC,使得新对象晋升到老年代使得老年代内存不足而触发FullGC,或者是大对象直接进入老年代导致老年代内存不足而触发</li>
<li>FullGC采用标记-整理算法,因为每次GC后会造成大量的内存碎片,造成内存的不连续性,所以FullGC首先会先扫描一遍老年代,标记存活和要回收的对象,然后在进行整理,是存活的对象都移动到一端,最后直接对端边界的内存(回收对象)进行回收</li>
<li>如果当老年代也装不下的时候就会抛出Out of Memeory(OOM)异常</li>
</ul>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/09/2019-01-09-jvm类加载器/">JVM类加载器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JVM/">JVM</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JVM/">JVM</a></span><div class="content"><h2 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器"></a>什么是类加载器</h2><blockquote>
<p>虚拟机用来实现让应用程序自己决定如何去获取所需要的类</p>
</blockquote>
<h2 id="类和类加载器"><a href="#类和类加载器" class="headerlink" title="类和类加载器"></a>类和类加载器</h2><blockquote>
<ul>
<li>对于任何一个类,都需要由加载他的类加载器和这个类本身一起确定其在java虚拟机中的唯一性,每个类加载器,都拥有一个独立的类名称空间.也就是比较两个类时候”相等”,只有在这两个类由同一个类加载器加载的前提下,否则两个类来源于同一个class文件,被同一个虚拟机加载,只要这两个类的加载器不同,那这两个类必然不相等</li>
<li>常见的方法有Class对象的equals(),isAssignableFrom(),isInstance()方法,也包括使用instanceof关键字的返回结果</li>
</ul>
</blockquote>
<blockquote>
<h3 id="从虚拟机的的角度讲-只存在两种不同的类加载器"><a href="#从虚拟机的的角度讲-只存在两种不同的类加载器" class="headerlink" title="从虚拟机的的角度讲,只存在两种不同的类加载器"></a>从虚拟机的的角度讲,只存在两种不同的类加载器</h3><ul>
<li>一种是启动类加载器(bootstrap classloader),这个类加载器使用C++实现,是虚拟机自身的一部分,无法直接被java程序引用</li>
<li>一种就是所有其他的类加载器,这类加载器都有java实现,独立于虚拟机外部,并且全部集成java.lang.ClassLoader</li>
</ul>
</blockquote>
<h2 id="类加载模型"><a href="#类加载模型" class="headerlink" title="类加载模型"></a>类加载模型</h2><blockquote>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul>
<li>模型层级: 启动类加载器(bootstrap classloader) &lt;- 拓展类加载器(Extension classloader):负责加载&lt;JAVA_HOME&gt;\lib\ext目录中或者被java.ext.dirs系统变量实现的所有类库 &lt;- 应用程序类加载器(Application classloader):开发者可以直接使用的 &lt;- 自定义类加载器</li>
<li>双亲委派模型要求除了顶层的启动类加载器外,其余的类都应当有自己的父类加载器,这里类加载器之间父子关系一般不会用继承的方式,而都是使用组合关系来复用父加载器的代码<br>工作过程:如果一个类加载器收到了类加载请求,它首先不会自己去尝试加载这个类,而是会把这个请求委派给父类加载器去完成,每一个层次的类加载器都是如此,因此所有加载请求最终都应该传送到顶层的启动类加载器中,只有当父加载器反馈自己无法完成这个请求的时候(他的搜索范围没有找到所需要的类),子加载器才会尝试自己去加载</li>
<li>参照ClassLoader中的代码</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先检查请求的类是否被加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// 如果父类加载器抛出ClassNotFoundException 说明父类无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果没有在父类找到该类</span></span><br><span class="line">                    <span class="comment">// 调用自身的findClass</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这是定义的类加载器;记录统计数据</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><ul>
<li>在java中大部分类加载器都遵循双亲委派模型,但是有两种场景会破坏双亲委派:</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>1.SPI对资源进行集中管理的时候,这时候采用了一种不太优雅的设计线程上线文类加载器(Thread Context ClassLoader),这个类加载器可以用过java.lang.Thread类setContextClassLoader方法进行设置,如果创建的线程还未设置,它将会从父线程集成一个,如果在应用程序全局范围内没有设置过的话,那么这个类加载器默认就是应用程序类加载器,这样就可以实现父类加载器去请求子类加载器,这块在之前dubbo spi中有做说明<br><a href="http://blog.leishunyu.com/2018/12/05/2018-12-05-Dubbo%20SPI%20%E6%9C%BA%E5%88%B6/">Dubbo SPI</a></p>
</li>
<li><p>2.在OSGI中实现热部署,模块热部署这些情况下会出现更复杂的网状结构</p>
</li>
<li>3.最后要注意的就是这两种类加载模型都不是强一致性的约束</li>
</ul>
</blockquote>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By 怀风</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>